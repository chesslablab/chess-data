{"ast":null,"code":"/**\n * Module dependencies\n */\nvar balanced = require(\"balanced-match\");\n\nvar reduceFunctionCall = require(\"reduce-function-call\");\n\nvar mexp = require(\"math-expression-evaluator\");\n/**\n * Constantes\n */\n\n\nvar MAX_STACK = 100; // should be enough for a single calc()...\n\nvar NESTED_CALC_RE = /(\\+|\\-|\\*|\\\\|[^a-z]|)(\\s*)(\\()/g;\n/**\n * Global variables\n */\n\nvar stack;\n/**\n * Expose reduceCSSCalc plugin\n *\n * @type {Function}\n */\n\nmodule.exports = reduceCSSCalc;\n/**\n * Reduce CSS calc() in a string, whenever it's possible\n *\n * @param {String} value css input\n */\n\nfunction reduceCSSCalc(value, decimalPrecision) {\n  stack = 0;\n  decimalPrecision = Math.pow(10, decimalPrecision === undefined ? 5 : decimalPrecision); // Allow calc() on multiple lines\n\n  value = value.replace(/\\n+/g, \" \");\n  /**\n   * Evaluates an expression\n   *\n   * @param {String} expression\n   * @returns {String}\n   */\n\n  function evaluateExpression(expression, functionIdentifier, call) {\n    if (stack++ > MAX_STACK) {\n      stack = 0;\n      throw new Error(\"Call stack overflow for \" + call);\n    }\n\n    if (expression === \"\") {\n      throw new Error(functionIdentifier + \"(): '\" + call + \"' must contain a non-whitespace string\");\n    }\n\n    expression = evaluateNestedExpression(expression, call);\n    var units = getUnitsInExpression(expression); // If the expression contains multiple units or CSS variables,\n    // then let the expression be (i.e. browser calc())\n\n    if (units.length > 1 || expression.indexOf(\"var(\") > -1) {\n      return functionIdentifier + \"(\" + expression + \")\";\n    }\n\n    var unit = units[0] || \"\";\n\n    if (unit === \"%\") {\n      // Convert percentages to numbers, to handle expressions like: 50% * 50% (will become: 25%):\n      // console.log(expression)\n      expression = expression.replace(/\\b[0-9\\.]+%/g, function (percent) {\n        return parseFloat(percent.slice(0, -1)) * 0.01;\n      });\n    } // Remove units in expression:\n\n\n    var toEvaluate = expression.replace(new RegExp(unit, \"gi\"), \"\");\n    var result;\n\n    try {\n      result = mexp.eval(toEvaluate);\n    } catch (e) {\n      return functionIdentifier + \"(\" + expression + \")\";\n    } // Transform back to a percentage result:\n\n\n    if (unit === \"%\") {\n      result *= 100;\n    } // adjust rounding shit\n    // (0.1 * 0.2 === 0.020000000000000004)\n\n\n    if (functionIdentifier.length || unit === \"%\") {\n      result = Math.round(result * decimalPrecision) / decimalPrecision;\n    } // Add unit\n\n\n    result += unit;\n    return result;\n  }\n  /**\n   * Evaluates nested expressions\n   *\n   * @param {String} expression\n   * @returns {String}\n   */\n\n\n  function evaluateNestedExpression(expression, call) {\n    // Remove the calc part from nested expressions to ensure\n    // better browser compatibility\n    expression = expression.replace(/((?:\\-[a-z]+\\-)?calc)/g, \"\");\n    var evaluatedPart = \"\";\n    var nonEvaluatedPart = expression;\n    var matches;\n\n    while (matches = NESTED_CALC_RE.exec(nonEvaluatedPart)) {\n      if (matches[0].index > 0) {\n        evaluatedPart += nonEvaluatedPart.substring(0, matches[0].index);\n      }\n\n      var balancedExpr = balanced(\"(\", \")\", nonEvaluatedPart.substring([0].index));\n\n      if (balancedExpr.body === \"\") {\n        throw new Error(\"'\" + expression + \"' must contain a non-whitespace string\");\n      }\n\n      var evaluated = evaluateExpression(balancedExpr.body, \"\", call);\n      evaluatedPart += balancedExpr.pre + evaluated;\n      nonEvaluatedPart = balancedExpr.post;\n    }\n\n    return evaluatedPart + nonEvaluatedPart;\n  }\n\n  return reduceFunctionCall(value, /((?:\\-[a-z]+\\-)?calc)\\(/, evaluateExpression);\n}\n/**\n * Checks what units are used in an expression\n *\n * @param {String} expression\n * @returns {Array}\n */\n\n\nfunction getUnitsInExpression(expression) {\n  var uniqueUnits = [];\n  var uniqueLowerCaseUnits = [];\n  var unitRegEx = /[\\.0-9]([%a-z]+)/gi;\n  var matches = unitRegEx.exec(expression);\n\n  while (matches) {\n    if (!matches || !matches[1]) {\n      continue;\n    }\n\n    if (uniqueLowerCaseUnits.indexOf(matches[1].toLowerCase()) === -1) {\n      uniqueUnits.push(matches[1]);\n      uniqueLowerCaseUnits.push(matches[1].toLowerCase());\n    }\n\n    matches = unitRegEx.exec(expression);\n  }\n\n  return uniqueUnits;\n}","map":{"version":3,"sources":["/usr/share/pgn-chess/node_modules/reduce-css-calc/index.js"],"names":["balanced","require","reduceFunctionCall","mexp","MAX_STACK","NESTED_CALC_RE","stack","module","exports","reduceCSSCalc","value","decimalPrecision","Math","pow","undefined","replace","evaluateExpression","expression","functionIdentifier","call","Error","evaluateNestedExpression","units","getUnitsInExpression","length","indexOf","unit","percent","parseFloat","slice","toEvaluate","RegExp","result","eval","e","round","evaluatedPart","nonEvaluatedPart","matches","exec","index","substring","balancedExpr","body","evaluated","pre","post","uniqueUnits","uniqueLowerCaseUnits","unitRegEx","toLowerCase","push"],"mappings":"AAAA;;;AAGA,IAAIA,QAAQ,GAAGC,OAAO,CAAC,gBAAD,CAAtB;;AACA,IAAIC,kBAAkB,GAAGD,OAAO,CAAC,sBAAD,CAAhC;;AACA,IAAIE,IAAI,GAAGF,OAAO,CAAC,2BAAD,CAAlB;AAEA;;;;;AAGA,IAAIG,SAAS,GAAG,GAAhB,C,CAAoB;;AACpB,IAAIC,cAAc,GAAG,iCAArB;AAEA;;;;AAGA,IAAIC,KAAJ;AAEA;;;;;;AAKAC,MAAM,CAACC,OAAP,GAAiBC,aAAjB;AAEA;;;;;;AAKA,SAASA,aAAT,CAAuBC,KAAvB,EAA8BC,gBAA9B,EAAgD;AAC9CL,EAAAA,KAAK,GAAG,CAAR;AACAK,EAAAA,gBAAgB,GAAGC,IAAI,CAACC,GAAL,CAAS,EAAT,EAAaF,gBAAgB,KAAKG,SAArB,GAAiC,CAAjC,GAAqCH,gBAAlD,CAAnB,CAF8C,CAI9C;;AACAD,EAAAA,KAAK,GAAGA,KAAK,CAACK,OAAN,CAAc,MAAd,EAAsB,GAAtB,CAAR;AAEA;;;;;;;AAMA,WAASC,kBAAT,CAA6BC,UAA7B,EAAyCC,kBAAzC,EAA6DC,IAA7D,EAAmE;AACjE,QAAIb,KAAK,KAAKF,SAAd,EAAyB;AACvBE,MAAAA,KAAK,GAAG,CAAR;AACA,YAAM,IAAIc,KAAJ,CAAU,6BAA6BD,IAAvC,CAAN;AACD;;AAED,QAAIF,UAAU,KAAK,EAAnB,EAAuB;AACrB,YAAM,IAAIG,KAAJ,CAAUF,kBAAkB,GAAG,OAArB,GAA+BC,IAA/B,GAAsC,wCAAhD,CAAN;AACD;;AAEDF,IAAAA,UAAU,GAAGI,wBAAwB,CAACJ,UAAD,EAAaE,IAAb,CAArC;AAEA,QAAIG,KAAK,GAAGC,oBAAoB,CAACN,UAAD,CAAhC,CAZiE,CAcjE;AACA;;AACA,QAAIK,KAAK,CAACE,MAAN,GAAe,CAAf,IAAoBP,UAAU,CAACQ,OAAX,CAAmB,MAAnB,IAA6B,CAAC,CAAtD,EAAyD;AACvD,aAAOP,kBAAkB,GAAG,GAArB,GAA2BD,UAA3B,GAAwC,GAA/C;AACD;;AAED,QAAIS,IAAI,GAAGJ,KAAK,CAAC,CAAD,CAAL,IAAY,EAAvB;;AAEA,QAAII,IAAI,KAAK,GAAb,EAAkB;AAChB;AACA;AACAT,MAAAA,UAAU,GAAGA,UAAU,CAACF,OAAX,CAAmB,cAAnB,EAAmC,UAASY,OAAT,EAAkB;AAChE,eAAOC,UAAU,CAACD,OAAO,CAACE,KAAR,CAAc,CAAd,EAAiB,CAAC,CAAlB,CAAD,CAAV,GAAmC,IAA1C;AACD,OAFY,CAAb;AAGD,KA5BgE,CA8BjE;;;AACA,QAAIC,UAAU,GAAGb,UAAU,CAACF,OAAX,CAAmB,IAAIgB,MAAJ,CAAWL,IAAX,EAAiB,IAAjB,CAAnB,EAA2C,EAA3C,CAAjB;AACA,QAAIM,MAAJ;;AAEA,QAAI;AACFA,MAAAA,MAAM,GAAG7B,IAAI,CAAC8B,IAAL,CAAUH,UAAV,CAAT;AACD,KAFD,CAGA,OAAOI,CAAP,EAAU;AACR,aAAOhB,kBAAkB,GAAG,GAArB,GAA2BD,UAA3B,GAAwC,GAA/C;AACD,KAvCgE,CAyCjE;;;AACA,QAAIS,IAAI,KAAK,GAAb,EAAkB;AAChBM,MAAAA,MAAM,IAAI,GAAV;AACD,KA5CgE,CA8CjE;AACA;;;AACA,QAAId,kBAAkB,CAACM,MAAnB,IAA6BE,IAAI,KAAK,GAA1C,EAA+C;AAC7CM,MAAAA,MAAM,GAAGpB,IAAI,CAACuB,KAAL,CAAWH,MAAM,GAAGrB,gBAApB,IAAwCA,gBAAjD;AACD,KAlDgE,CAoDjE;;;AACAqB,IAAAA,MAAM,IAAIN,IAAV;AAEA,WAAOM,MAAP;AACD;AAED;;;;;;;;AAMA,WAASX,wBAAT,CAAkCJ,UAAlC,EAA8CE,IAA9C,EAAoD;AAClD;AACA;AACAF,IAAAA,UAAU,GAAGA,UAAU,CAACF,OAAX,CAAmB,wBAAnB,EAA6C,EAA7C,CAAb;AACA,QAAIqB,aAAa,GAAG,EAApB;AACA,QAAIC,gBAAgB,GAAGpB,UAAvB;AACA,QAAIqB,OAAJ;;AACA,WAAQA,OAAO,GAAGjC,cAAc,CAACkC,IAAf,CAAoBF,gBAApB,CAAlB,EAA0D;AACxD,UAAIC,OAAO,CAAC,CAAD,CAAP,CAAWE,KAAX,GAAmB,CAAvB,EAA0B;AACxBJ,QAAAA,aAAa,IAAIC,gBAAgB,CAACI,SAAjB,CAA2B,CAA3B,EAA8BH,OAAO,CAAC,CAAD,CAAP,CAAWE,KAAzC,CAAjB;AACD;;AAED,UAAIE,YAAY,GAAG1C,QAAQ,CAAC,GAAD,EAAM,GAAN,EAAWqC,gBAAgB,CAACI,SAAjB,CAA2B,CAAC,CAAD,EAAID,KAA/B,CAAX,CAA3B;;AACA,UAAIE,YAAY,CAACC,IAAb,KAAsB,EAA1B,EAA8B;AAC5B,cAAM,IAAIvB,KAAJ,CAAU,MAAMH,UAAN,GAAmB,wCAA7B,CAAN;AACD;;AAED,UAAI2B,SAAS,GAAG5B,kBAAkB,CAAC0B,YAAY,CAACC,IAAd,EAAoB,EAApB,EAAwBxB,IAAxB,CAAlC;AAEAiB,MAAAA,aAAa,IAAIM,YAAY,CAACG,GAAb,GAAmBD,SAApC;AACAP,MAAAA,gBAAgB,GAAGK,YAAY,CAACI,IAAhC;AACD;;AAED,WAAOV,aAAa,GAAGC,gBAAvB;AACD;;AAED,SAAOnC,kBAAkB,CAACQ,KAAD,EAAQ,yBAAR,EAAmCM,kBAAnC,CAAzB;AACD;AAED;;;;;;;;AAOA,SAASO,oBAAT,CAA8BN,UAA9B,EAA0C;AACxC,MAAI8B,WAAW,GAAG,EAAlB;AACA,MAAIC,oBAAoB,GAAG,EAA3B;AACA,MAAIC,SAAS,GAAG,oBAAhB;AACA,MAAIX,OAAO,GAAGW,SAAS,CAACV,IAAV,CAAetB,UAAf,CAAd;;AAEA,SAAOqB,OAAP,EAAgB;AACd,QAAI,CAACA,OAAD,IAAY,CAACA,OAAO,CAAC,CAAD,CAAxB,EAA6B;AAC3B;AACD;;AAED,QAAIU,oBAAoB,CAACvB,OAArB,CAA6Ba,OAAO,CAAC,CAAD,CAAP,CAAWY,WAAX,EAA7B,MAA2D,CAAC,CAAhE,EAAmE;AACjEH,MAAAA,WAAW,CAACI,IAAZ,CAAiBb,OAAO,CAAC,CAAD,CAAxB;AACAU,MAAAA,oBAAoB,CAACG,IAArB,CAA0Bb,OAAO,CAAC,CAAD,CAAP,CAAWY,WAAX,EAA1B;AACD;;AAEDZ,IAAAA,OAAO,GAAGW,SAAS,CAACV,IAAV,CAAetB,UAAf,CAAV;AACD;;AAED,SAAO8B,WAAP;AACD","sourcesContent":["/**\n * Module dependencies\n */\nvar balanced = require(\"balanced-match\")\nvar reduceFunctionCall = require(\"reduce-function-call\")\nvar mexp = require(\"math-expression-evaluator\")\n\n/**\n * Constantes\n */\nvar MAX_STACK = 100 // should be enough for a single calc()...\nvar NESTED_CALC_RE = /(\\+|\\-|\\*|\\\\|[^a-z]|)(\\s*)(\\()/g\n\n/**\n * Global variables\n */\nvar stack\n\n/**\n * Expose reduceCSSCalc plugin\n *\n * @type {Function}\n */\nmodule.exports = reduceCSSCalc\n\n/**\n * Reduce CSS calc() in a string, whenever it's possible\n *\n * @param {String} value css input\n */\nfunction reduceCSSCalc(value, decimalPrecision) {\n  stack = 0\n  decimalPrecision = Math.pow(10, decimalPrecision === undefined ? 5 : decimalPrecision)\n\n  // Allow calc() on multiple lines\n  value = value.replace(/\\n+/g, \" \")\n\n  /**\n   * Evaluates an expression\n   *\n   * @param {String} expression\n   * @returns {String}\n   */\n  function evaluateExpression (expression, functionIdentifier, call) {\n    if (stack++ > MAX_STACK) {\n      stack = 0\n      throw new Error(\"Call stack overflow for \" + call)\n    }\n\n    if (expression === \"\") {\n      throw new Error(functionIdentifier + \"(): '\" + call + \"' must contain a non-whitespace string\")\n    }\n\n    expression = evaluateNestedExpression(expression, call)\n\n    var units = getUnitsInExpression(expression)\n\n    // If the expression contains multiple units or CSS variables,\n    // then let the expression be (i.e. browser calc())\n    if (units.length > 1 || expression.indexOf(\"var(\") > -1) {\n      return functionIdentifier + \"(\" + expression + \")\"\n    }\n\n    var unit = units[0] || \"\"\n\n    if (unit === \"%\") {\n      // Convert percentages to numbers, to handle expressions like: 50% * 50% (will become: 25%):\n      // console.log(expression)\n      expression = expression.replace(/\\b[0-9\\.]+%/g, function(percent) {\n        return parseFloat(percent.slice(0, -1)) * 0.01\n      })\n    }\n\n    // Remove units in expression:\n    var toEvaluate = expression.replace(new RegExp(unit, \"gi\"), \"\")\n    var result\n\n    try {\n      result = mexp.eval(toEvaluate)\n    }\n    catch (e) {\n      return functionIdentifier + \"(\" + expression + \")\"\n    }\n\n    // Transform back to a percentage result:\n    if (unit === \"%\") {\n      result *= 100\n    }\n\n    // adjust rounding shit\n    // (0.1 * 0.2 === 0.020000000000000004)\n    if (functionIdentifier.length || unit === \"%\") {\n      result = Math.round(result * decimalPrecision) / decimalPrecision\n    }\n\n    // Add unit\n    result += unit\n\n    return result\n  }\n\n  /**\n   * Evaluates nested expressions\n   *\n   * @param {String} expression\n   * @returns {String}\n   */\n  function evaluateNestedExpression(expression, call) {\n    // Remove the calc part from nested expressions to ensure\n    // better browser compatibility\n    expression = expression.replace(/((?:\\-[a-z]+\\-)?calc)/g, \"\")\n    var evaluatedPart = \"\"\n    var nonEvaluatedPart = expression\n    var matches\n    while ((matches = NESTED_CALC_RE.exec(nonEvaluatedPart))) {\n      if (matches[0].index > 0) {\n        evaluatedPart += nonEvaluatedPart.substring(0, matches[0].index)\n      }\n\n      var balancedExpr = balanced(\"(\", \")\", nonEvaluatedPart.substring([0].index))\n      if (balancedExpr.body === \"\") {\n        throw new Error(\"'\" + expression + \"' must contain a non-whitespace string\")\n      }\n\n      var evaluated = evaluateExpression(balancedExpr.body, \"\", call)\n\n      evaluatedPart += balancedExpr.pre + evaluated\n      nonEvaluatedPart = balancedExpr.post\n    }\n\n    return evaluatedPart + nonEvaluatedPart\n  }\n\n  return reduceFunctionCall(value, /((?:\\-[a-z]+\\-)?calc)\\(/, evaluateExpression)\n}\n\n/**\n * Checks what units are used in an expression\n *\n * @param {String} expression\n * @returns {Array}\n */\n\nfunction getUnitsInExpression(expression) {\n  var uniqueUnits = []\n  var uniqueLowerCaseUnits = []\n  var unitRegEx = /[\\.0-9]([%a-z]+)/gi\n  var matches = unitRegEx.exec(expression)\n\n  while (matches) {\n    if (!matches || !matches[1]) {\n      continue\n    }\n\n    if (uniqueLowerCaseUnits.indexOf(matches[1].toLowerCase()) === -1) {\n      uniqueUnits.push(matches[1])\n      uniqueLowerCaseUnits.push(matches[1].toLowerCase())\n    }\n\n    matches = unitRegEx.exec(expression)\n  }\n\n  return uniqueUnits\n}\n"]},"metadata":{},"sourceType":"script"}