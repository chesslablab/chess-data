{"ast":null,"code":"/*! decimal.js-light v2.5.0 https://github.com/MikeMcl/decimal.js-light/LICENCE */\n;\n\n(function (globalScope) {\n  'use strict';\n  /*\r\n   *  decimal.js-light v2.5.0\r\n   *  An arbitrary-precision Decimal type for JavaScript.\r\n   *  https://github.com/MikeMcl/decimal.js-light\r\n   *  Copyright (c) 2018 Michael Mclaughlin <M8ch88l@gmail.com>\r\n   *  MIT Expat Licence\r\n   */\n  // -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //\n  // The limit on the value of `precision`, and on the value of the first argument to\n  // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.\n\n  var MAX_DIGITS = 1e9,\n      // 0 to 1e9\n  // The initial configuration properties of the Decimal constructor.\n  Decimal = {\n    // These values must be integers within the stated ranges (inclusive).\n    // Most of these values can be changed during run-time using `Decimal.config`.\n    // The maximum number of significant digits of the result of a calculation or base conversion.\n    // E.g. `Decimal.config({ precision: 20 });`\n    precision: 20,\n    // 1 to MAX_DIGITS\n    // The rounding mode used by default by `toInteger`, `toDecimalPlaces`, `toExponential`,\n    // `toFixed`, `toPrecision` and `toSignificantDigits`.\n    //\n    // ROUND_UP         0 Away from zero.\n    // ROUND_DOWN       1 Towards zero.\n    // ROUND_CEIL       2 Towards +Infinity.\n    // ROUND_FLOOR      3 Towards -Infinity.\n    // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.\n    // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\n    // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\n    // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\n    // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\n    //\n    // E.g.\n    // `Decimal.rounding = 4;`\n    // `Decimal.rounding = Decimal.ROUND_HALF_UP;`\n    rounding: 4,\n    // 0 to 8\n    // The exponent value at and beneath which `toString` returns exponential notation.\n    // JavaScript numbers: -7\n    toExpNeg: -7,\n    // 0 to -MAX_E\n    // The exponent value at and above which `toString` returns exponential notation.\n    // JavaScript numbers: 21\n    toExpPos: 21,\n    // 0 to MAX_E\n    // The natural logarithm of 10.\n    // 115 digits\n    LN10: '2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286'\n  },\n      // ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //\n  external = true,\n      decimalError = '[DecimalError] ',\n      invalidArgument = decimalError + 'Invalid argument: ',\n      exponentOutOfRange = decimalError + 'Exponent out of range: ',\n      mathfloor = Math.floor,\n      mathpow = Math.pow,\n      isDecimal = /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i,\n      ONE,\n      BASE = 1e7,\n      LOG_BASE = 7,\n      MAX_SAFE_INTEGER = 9007199254740991,\n      MAX_E = mathfloor(MAX_SAFE_INTEGER / LOG_BASE),\n      // 1286742750677284\n  // Decimal.prototype object\n  P = {}; // Decimal prototype methods\n\n  /*\r\n   *  absoluteValue                       abs\r\n   *  comparedTo                          cmp\r\n   *  decimalPlaces                       dp\r\n   *  dividedBy                           div\r\n   *  dividedToIntegerBy                  idiv\r\n   *  equals                              eq\r\n   *  exponent\r\n   *  greaterThan                         gt\r\n   *  greaterThanOrEqualTo                gte\r\n   *  isInteger                           isint\r\n   *  isNegative                          isneg\r\n   *  isPositive                          ispos\r\n   *  isZero\r\n   *  lessThan                            lt\r\n   *  lessThanOrEqualTo                   lte\r\n   *  logarithm                           log\r\n   *  minus                               sub\r\n   *  modulo                              mod\r\n   *  naturalExponential                  exp\r\n   *  naturalLogarithm                    ln\r\n   *  negated                             neg\r\n   *  plus                                add\r\n   *  precision                           sd\r\n   *  squareRoot                          sqrt\r\n   *  times                               mul\r\n   *  toDecimalPlaces                     todp\r\n   *  toExponential\r\n   *  toFixed\r\n   *  toInteger                           toint\r\n   *  toNumber\r\n   *  toPower                             pow\r\n   *  toPrecision\r\n   *  toSignificantDigits                 tosd\r\n   *  toString\r\n   *  valueOf                             val\r\n   */\n\n  /*\r\n   * Return a new Decimal whose value is the absolute value of this Decimal.\r\n   *\r\n   */\n\n  P.absoluteValue = P.abs = function () {\n    var x = new this.constructor(this);\n    if (x.s) x.s = 1;\n    return x;\n  };\n  /*\r\n   * Return\r\n   *   1    if the value of this Decimal is greater than the value of `y`,\r\n   *  -1    if the value of this Decimal is less than the value of `y`,\r\n   *   0    if they have the same value\r\n   *\r\n   */\n\n\n  P.comparedTo = P.cmp = function (y) {\n    var i,\n        j,\n        xdL,\n        ydL,\n        x = this;\n    y = new x.constructor(y); // Signs differ?\n\n    if (x.s !== y.s) return x.s || -y.s; // Compare exponents.\n\n    if (x.e !== y.e) return x.e > y.e ^ x.s < 0 ? 1 : -1;\n    xdL = x.d.length;\n    ydL = y.d.length; // Compare digit by digit.\n\n    for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {\n      if (x.d[i] !== y.d[i]) return x.d[i] > y.d[i] ^ x.s < 0 ? 1 : -1;\n    } // Compare lengths.\n\n\n    return xdL === ydL ? 0 : xdL > ydL ^ x.s < 0 ? 1 : -1;\n  };\n  /*\r\n   * Return the number of decimal places of the value of this Decimal.\r\n   *\r\n   */\n\n\n  P.decimalPlaces = P.dp = function () {\n    var x = this,\n        w = x.d.length - 1,\n        dp = (w - x.e) * LOG_BASE; // Subtract the number of trailing zeros of the last word.\n\n    w = x.d[w];\n    if (w) for (; w % 10 == 0; w /= 10) dp--;\n    return dp < 0 ? 0 : dp;\n  };\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal divided by `y`, truncated to\r\n   * `precision` significant digits.\r\n   *\r\n   */\n\n\n  P.dividedBy = P.div = function (y) {\n    return divide(this, new this.constructor(y));\n  };\n  /*\r\n   * Return a new Decimal whose value is the integer part of dividing the value of this Decimal\r\n   * by the value of `y`, truncated to `precision` significant digits.\r\n   *\r\n   */\n\n\n  P.dividedToIntegerBy = P.idiv = function (y) {\n    var x = this,\n        Ctor = x.constructor;\n    return round(divide(x, new Ctor(y), 0, 1), Ctor.precision);\n  };\n  /*\r\n   * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.\r\n   *\r\n   */\n\n\n  P.equals = P.eq = function (y) {\n    return !this.cmp(y);\n  };\n  /*\r\n   * Return the (base 10) exponent value of this Decimal (this.e is the base 10000000 exponent).\r\n   *\r\n   */\n\n\n  P.exponent = function () {\n    return getBase10Exponent(this);\n  };\n  /*\r\n   * Return true if the value of this Decimal is greater than the value of `y`, otherwise return\r\n   * false.\r\n   *\r\n   */\n\n\n  P.greaterThan = P.gt = function (y) {\n    return this.cmp(y) > 0;\n  };\n  /*\r\n   * Return true if the value of this Decimal is greater than or equal to the value of `y`,\r\n   * otherwise return false.\r\n   *\r\n   */\n\n\n  P.greaterThanOrEqualTo = P.gte = function (y) {\n    return this.cmp(y) >= 0;\n  };\n  /*\r\n   * Return true if the value of this Decimal is an integer, otherwise return false.\r\n   *\r\n   */\n\n\n  P.isInteger = P.isint = function () {\n    return this.e > this.d.length - 2;\n  };\n  /*\r\n   * Return true if the value of this Decimal is negative, otherwise return false.\r\n   *\r\n   */\n\n\n  P.isNegative = P.isneg = function () {\n    return this.s < 0;\n  };\n  /*\r\n   * Return true if the value of this Decimal is positive, otherwise return false.\r\n   *\r\n   */\n\n\n  P.isPositive = P.ispos = function () {\n    return this.s > 0;\n  };\n  /*\r\n   * Return true if the value of this Decimal is 0, otherwise return false.\r\n   *\r\n   */\n\n\n  P.isZero = function () {\n    return this.s === 0;\n  };\n  /*\r\n   * Return true if the value of this Decimal is less than `y`, otherwise return false.\r\n   *\r\n   */\n\n\n  P.lessThan = P.lt = function (y) {\n    return this.cmp(y) < 0;\n  };\n  /*\r\n   * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.\r\n   *\r\n   */\n\n\n  P.lessThanOrEqualTo = P.lte = function (y) {\n    return this.cmp(y) < 1;\n  };\n  /*\r\n   * Return the logarithm of the value of this Decimal to the specified base, truncated to\r\n   * `precision` significant digits.\r\n   *\r\n   * If no base is specified, return log[10](x).\r\n   *\r\n   * log[base](x) = ln(x) / ln(base)\r\n   *\r\n   * The maximum error of the result is 1 ulp (unit in the last place).\r\n   *\r\n   * [base] {number|string|Decimal} The base of the logarithm.\r\n   *\r\n   */\n\n\n  P.logarithm = P.log = function (base) {\n    var r,\n        x = this,\n        Ctor = x.constructor,\n        pr = Ctor.precision,\n        wpr = pr + 5; // Default base is 10.\n\n    if (base === void 0) {\n      base = new Ctor(10);\n    } else {\n      base = new Ctor(base); // log[-b](x) = NaN\n      // log[0](x)  = NaN\n      // log[1](x)  = NaN\n\n      if (base.s < 1 || base.eq(ONE)) throw Error(decimalError + 'NaN');\n    } // log[b](-x) = NaN\n    // log[b](0) = -Infinity\n\n\n    if (x.s < 1) throw Error(decimalError + (x.s ? 'NaN' : '-Infinity')); // log[b](1) = 0\n\n    if (x.eq(ONE)) return new Ctor(0);\n    external = false;\n    r = divide(ln(x, wpr), ln(base, wpr), wpr);\n    external = true;\n    return round(r, pr);\n  };\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal minus `y`, truncated to\r\n   * `precision` significant digits.\r\n   *\r\n   */\n\n\n  P.minus = P.sub = function (y) {\n    var x = this;\n    y = new x.constructor(y);\n    return x.s == y.s ? subtract(x, y) : add(x, (y.s = -y.s, y));\n  };\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal modulo `y`, truncated to\r\n   * `precision` significant digits.\r\n   *\r\n   */\n\n\n  P.modulo = P.mod = function (y) {\n    var q,\n        x = this,\n        Ctor = x.constructor,\n        pr = Ctor.precision;\n    y = new Ctor(y); // x % 0 = NaN\n\n    if (!y.s) throw Error(decimalError + 'NaN'); // Return x if x is 0.\n\n    if (!x.s) return round(new Ctor(x), pr); // Prevent rounding of intermediate calculations.\n\n    external = false;\n    q = divide(x, y, 0, 1).times(y);\n    external = true;\n    return x.minus(q);\n  };\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of the value of this Decimal,\r\n   * i.e. the base e raised to the power the value of this Decimal, truncated to `precision`\r\n   * significant digits.\r\n   *\r\n   */\n\n\n  P.naturalExponential = P.exp = function () {\n    return exp(this);\n  };\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,\r\n   * truncated to `precision` significant digits.\r\n   *\r\n   */\n\n\n  P.naturalLogarithm = P.ln = function () {\n    return ln(this);\n  };\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by\r\n   * -1.\r\n   *\r\n   */\n\n\n  P.negated = P.neg = function () {\n    var x = new this.constructor(this);\n    x.s = -x.s || 0;\n    return x;\n  };\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal plus `y`, truncated to\r\n   * `precision` significant digits.\r\n   *\r\n   */\n\n\n  P.plus = P.add = function (y) {\n    var x = this;\n    y = new x.constructor(y);\n    return x.s == y.s ? add(x, y) : subtract(x, (y.s = -y.s, y));\n  };\n  /*\r\n   * Return the number of significant digits of the value of this Decimal.\r\n   *\r\n   * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.\r\n   *\r\n   */\n\n\n  P.precision = P.sd = function (z) {\n    var e,\n        sd,\n        w,\n        x = this;\n    if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);\n    e = getBase10Exponent(x) + 1;\n    w = x.d.length - 1;\n    sd = w * LOG_BASE + 1;\n    w = x.d[w]; // If non-zero...\n\n    if (w) {\n      // Subtract the number of trailing zeros of the last word.\n      for (; w % 10 == 0; w /= 10) sd--; // Add the number of digits of the first word.\n\n\n      for (w = x.d[0]; w >= 10; w /= 10) sd++;\n    }\n\n    return z && e > sd ? e : sd;\n  };\n  /*\r\n   * Return a new Decimal whose value is the square root of this Decimal, truncated to `precision`\r\n   * significant digits.\r\n   *\r\n   */\n\n\n  P.squareRoot = P.sqrt = function () {\n    var e,\n        n,\n        pr,\n        r,\n        s,\n        t,\n        wpr,\n        x = this,\n        Ctor = x.constructor; // Negative or zero?\n\n    if (x.s < 1) {\n      if (!x.s) return new Ctor(0); // sqrt(-x) = NaN\n\n      throw Error(decimalError + 'NaN');\n    }\n\n    e = getBase10Exponent(x);\n    external = false; // Initial estimate.\n\n    s = Math.sqrt(+x); // Math.sqrt underflow/overflow?\n    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\n\n    if (s == 0 || s == 1 / 0) {\n      n = digitsToString(x.d);\n      if ((n.length + e) % 2 == 0) n += '0';\n      s = Math.sqrt(n);\n      e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);\n\n      if (s == 1 / 0) {\n        n = '1e' + e;\n      } else {\n        n = s.toExponential();\n        n = n.slice(0, n.indexOf('e') + 1) + e;\n      }\n\n      r = new Ctor(n);\n    } else {\n      r = new Ctor(s.toString());\n    }\n\n    pr = Ctor.precision;\n    s = wpr = pr + 3; // Newton-Raphson iteration.\n\n    for (;;) {\n      t = r;\n      r = t.plus(divide(x, t, wpr + 2)).times(0.5);\n\n      if (digitsToString(t.d).slice(0, wpr) === (n = digitsToString(r.d)).slice(0, wpr)) {\n        n = n.slice(wpr - 3, wpr + 1); // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or\n        // 4999, i.e. approaching a rounding boundary, continue the iteration.\n\n        if (s == wpr && n == '4999') {\n          // On the first iteration only, check to see if rounding up gives the exact result as the\n          // nines may infinitely repeat.\n          round(t, pr + 1, 0);\n\n          if (t.times(t).eq(x)) {\n            r = t;\n            break;\n          }\n        } else if (n != '9999') {\n          break;\n        }\n\n        wpr += 4;\n      }\n    }\n\n    external = true;\n    return round(r, pr);\n  };\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal times `y`, truncated to\r\n   * `precision` significant digits.\r\n   *\r\n   */\n\n\n  P.times = P.mul = function (y) {\n    var carry,\n        e,\n        i,\n        k,\n        r,\n        rL,\n        t,\n        xdL,\n        ydL,\n        x = this,\n        Ctor = x.constructor,\n        xd = x.d,\n        yd = (y = new Ctor(y)).d; // Return 0 if either is 0.\n\n    if (!x.s || !y.s) return new Ctor(0);\n    y.s *= x.s;\n    e = x.e + y.e;\n    xdL = xd.length;\n    ydL = yd.length; // Ensure xd points to the longer array.\n\n    if (xdL < ydL) {\n      r = xd;\n      xd = yd;\n      yd = r;\n      rL = xdL;\n      xdL = ydL;\n      ydL = rL;\n    } // Initialise the result array with zeros.\n\n\n    r = [];\n    rL = xdL + ydL;\n\n    for (i = rL; i--;) r.push(0); // Multiply!\n\n\n    for (i = ydL; --i >= 0;) {\n      carry = 0;\n\n      for (k = xdL + i; k > i;) {\n        t = r[k] + yd[i] * xd[k - i - 1] + carry;\n        r[k--] = t % BASE | 0;\n        carry = t / BASE | 0;\n      }\n\n      r[k] = (r[k] + carry) % BASE | 0;\n    } // Remove trailing zeros.\n\n\n    for (; !r[--rL];) r.pop();\n\n    if (carry) ++e;else r.shift();\n    y.d = r;\n    y.e = e;\n    return external ? round(y, Ctor.precision) : y;\n  };\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`\r\n   * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.\r\n   *\r\n   * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\n\n\n  P.toDecimalPlaces = P.todp = function (dp, rm) {\n    var x = this,\n        Ctor = x.constructor;\n    x = new Ctor(x);\n    if (dp === void 0) return x;\n    checkInt32(dp, 0, MAX_DIGITS);\n    if (rm === void 0) rm = Ctor.rounding;else checkInt32(rm, 0, 8);\n    return round(x, dp + getBase10Exponent(x) + 1, rm);\n  };\n  /*\r\n   * Return a string representing the value of this Decimal in exponential notation rounded to\r\n   * `dp` fixed decimal places using rounding mode `rounding`.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\n\n\n  P.toExponential = function (dp, rm) {\n    var str,\n        x = this,\n        Ctor = x.constructor;\n\n    if (dp === void 0) {\n      str = toString(x, true);\n    } else {\n      checkInt32(dp, 0, MAX_DIGITS);\n      if (rm === void 0) rm = Ctor.rounding;else checkInt32(rm, 0, 8);\n      x = round(new Ctor(x), dp + 1, rm);\n      str = toString(x, true, dp + 1);\n    }\n\n    return str;\n  };\n  /*\r\n   * Return a string representing the value of this Decimal in normal (fixed-point) notation to\r\n   * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is\r\n   * omitted.\r\n   *\r\n   * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\r\n   * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n   * (-0).toFixed(3) is '0.000'.\r\n   * (-0.5).toFixed(0) is '-0'.\r\n   *\r\n   */\n\n\n  P.toFixed = function (dp, rm) {\n    var str,\n        y,\n        x = this,\n        Ctor = x.constructor;\n    if (dp === void 0) return toString(x);\n    checkInt32(dp, 0, MAX_DIGITS);\n    if (rm === void 0) rm = Ctor.rounding;else checkInt32(rm, 0, 8);\n    y = round(new Ctor(x), dp + getBase10Exponent(x) + 1, rm);\n    str = toString(y.abs(), false, dp + getBase10Exponent(y) + 1); // To determine whether to add the minus sign look at the value before it was rounded,\n    // i.e. look at `x` rather than `y`.\n\n    return x.isneg() && !x.isZero() ? '-' + str : str;\n  };\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using\r\n   * rounding mode `rounding`.\r\n   *\r\n   */\n\n\n  P.toInteger = P.toint = function () {\n    var x = this,\n        Ctor = x.constructor;\n    return round(new Ctor(x), getBase10Exponent(x) + 1, Ctor.rounding);\n  };\n  /*\r\n   * Return the value of this Decimal converted to a number primitive.\r\n   *\r\n   */\n\n\n  P.toNumber = function () {\n    return +this;\n  };\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal raised to the power `y`,\r\n   * truncated to `precision` significant digits.\r\n   *\r\n   * For non-integer or very large exponents pow(x, y) is calculated using\r\n   *\r\n   *   x^y = exp(y*ln(x))\r\n   *\r\n   * The maximum error is 1 ulp (unit in last place).\r\n   *\r\n   * y {number|string|Decimal} The power to which to raise this Decimal.\r\n   *\r\n   */\n\n\n  P.toPower = P.pow = function (y) {\n    var e,\n        k,\n        pr,\n        r,\n        sign,\n        yIsInt,\n        x = this,\n        Ctor = x.constructor,\n        guard = 12,\n        yn = +(y = new Ctor(y)); // pow(x, 0) = 1\n\n    if (!y.s) return new Ctor(ONE);\n    x = new Ctor(x); // pow(0, y > 0) = 0\n    // pow(0, y < 0) = Infinity\n\n    if (!x.s) {\n      if (y.s < 1) throw Error(decimalError + 'Infinity');\n      return x;\n    } // pow(1, y) = 1\n\n\n    if (x.eq(ONE)) return x;\n    pr = Ctor.precision; // pow(x, 1) = x\n\n    if (y.eq(ONE)) return round(x, pr);\n    e = y.e;\n    k = y.d.length - 1;\n    yIsInt = e >= k;\n    sign = x.s;\n\n    if (!yIsInt) {\n      // pow(x < 0, y non-integer) = NaN\n      if (sign < 0) throw Error(decimalError + 'NaN'); // If y is a small integer use the 'exponentiation by squaring' algorithm.\n    } else if ((k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {\n      r = new Ctor(ONE); // Max k of 9007199254740991 takes 53 loop iterations.\n      // Maximum digits array length; leaves [28, 34] guard digits.\n\n      e = Math.ceil(pr / LOG_BASE + 4);\n      external = false;\n\n      for (;;) {\n        if (k % 2) {\n          r = r.times(x);\n          truncate(r.d, e);\n        }\n\n        k = mathfloor(k / 2);\n        if (k === 0) break;\n        x = x.times(x);\n        truncate(x.d, e);\n      }\n\n      external = true;\n      return y.s < 0 ? new Ctor(ONE).div(r) : round(r, pr);\n    } // Result is negative if x is negative and the last digit of integer y is odd.\n\n\n    sign = sign < 0 && y.d[Math.max(e, k)] & 1 ? -1 : 1;\n    x.s = 1;\n    external = false;\n    r = y.times(ln(x, pr + guard));\n    external = true;\n    r = exp(r);\n    r.s = sign;\n    return r;\n  };\n  /*\r\n   * Return a string representing the value of this Decimal rounded to `sd` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * Return exponential notation if `sd` is less than the number of digits necessary to represent\r\n   * the integer part of the value in normal notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\n\n\n  P.toPrecision = function (sd, rm) {\n    var e,\n        str,\n        x = this,\n        Ctor = x.constructor;\n\n    if (sd === void 0) {\n      e = getBase10Exponent(x);\n      str = toString(x, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);\n    } else {\n      checkInt32(sd, 1, MAX_DIGITS);\n      if (rm === void 0) rm = Ctor.rounding;else checkInt32(rm, 0, 8);\n      x = round(new Ctor(x), sd, rm);\n      e = getBase10Exponent(x);\n      str = toString(x, sd <= e || e <= Ctor.toExpNeg, sd);\n    }\n\n    return str;\n  };\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`\r\n   * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if\r\n   * omitted.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\n\n\n  P.toSignificantDigits = P.tosd = function (sd, rm) {\n    var x = this,\n        Ctor = x.constructor;\n\n    if (sd === void 0) {\n      sd = Ctor.precision;\n      rm = Ctor.rounding;\n    } else {\n      checkInt32(sd, 1, MAX_DIGITS);\n      if (rm === void 0) rm = Ctor.rounding;else checkInt32(rm, 0, 8);\n    }\n\n    return round(new Ctor(x), sd, rm);\n  };\n  /*\r\n   * Return a string representing the value of this Decimal.\r\n   *\r\n   * Return exponential notation if this Decimal has a positive exponent equal to or greater than\r\n   * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.\r\n   *\r\n   */\n\n\n  P.toString = P.valueOf = P.val = P.toJSON = function () {\n    var x = this,\n        e = getBase10Exponent(x),\n        Ctor = x.constructor;\n    return toString(x, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);\n  }; // Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.\n\n  /*\r\n   *  add                 P.minus, P.plus\r\n   *  checkInt32          P.todp, P.toExponential, P.toFixed, P.toPrecision, P.tosd\r\n   *  digitsToString      P.log, P.sqrt, P.pow, toString, exp, ln\r\n   *  divide              P.div, P.idiv, P.log, P.mod, P.sqrt, exp, ln\r\n   *  exp                 P.exp, P.pow\r\n   *  getBase10Exponent   P.exponent, P.sd, P.toint, P.sqrt, P.todp, P.toFixed, P.toPrecision,\r\n   *                      P.toString, divide, round, toString, exp, ln\r\n   *  getLn10             P.log, ln\r\n   *  getZeroString       digitsToString, toString\r\n   *  ln                  P.log, P.ln, P.pow, exp\r\n   *  parseDecimal        Decimal\r\n   *  round               P.abs, P.idiv, P.log, P.minus, P.mod, P.neg, P.plus, P.toint, P.sqrt,\r\n   *                      P.times, P.todp, P.toExponential, P.toFixed, P.pow, P.toPrecision, P.tosd,\r\n   *                      divide, getLn10, exp, ln\r\n   *  subtract            P.minus, P.plus\r\n   *  toString            P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf\r\n   *  truncate            P.pow\r\n   *\r\n   *  Throws:             P.log, P.mod, P.sd, P.sqrt, P.pow,  checkInt32, divide, round,\r\n   *                      getLn10, exp, ln, parseDecimal, Decimal, config\r\n   */\n\n\n  function add(x, y) {\n    var carry,\n        d,\n        e,\n        i,\n        k,\n        len,\n        xd,\n        yd,\n        Ctor = x.constructor,\n        pr = Ctor.precision; // If either is zero...\n\n    if (!x.s || !y.s) {\n      // Return x if y is zero.\n      // Return y if y is non-zero.\n      if (!y.s) y = new Ctor(x);\n      return external ? round(y, pr) : y;\n    }\n\n    xd = x.d;\n    yd = y.d; // x and y are finite, non-zero numbers with the same sign.\n\n    k = x.e;\n    e = y.e;\n    xd = xd.slice();\n    i = k - e; // If base 1e7 exponents differ...\n\n    if (i) {\n      if (i < 0) {\n        d = xd;\n        i = -i;\n        len = yd.length;\n      } else {\n        d = yd;\n        e = k;\n        len = xd.length;\n      } // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.\n\n\n      k = Math.ceil(pr / LOG_BASE);\n      len = k > len ? k + 1 : len + 1;\n\n      if (i > len) {\n        i = len;\n        d.length = 1;\n      } // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.\n\n\n      d.reverse();\n\n      for (; i--;) d.push(0);\n\n      d.reverse();\n    }\n\n    len = xd.length;\n    i = yd.length; // If yd is longer than xd, swap xd and yd so xd points to the longer array.\n\n    if (len - i < 0) {\n      i = len;\n      d = yd;\n      yd = xd;\n      xd = d;\n    } // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.\n\n\n    for (carry = 0; i;) {\n      carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;\n      xd[i] %= BASE;\n    }\n\n    if (carry) {\n      xd.unshift(carry);\n      ++e;\n    } // Remove trailing zeros.\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\n\n\n    for (len = xd.length; xd[--len] == 0;) xd.pop();\n\n    y.d = xd;\n    y.e = e;\n    return external ? round(y, pr) : y;\n  }\n\n  function checkInt32(i, min, max) {\n    if (i !== ~~i || i < min || i > max) {\n      throw Error(invalidArgument + i);\n    }\n  }\n\n  function digitsToString(d) {\n    var i,\n        k,\n        ws,\n        indexOfLastWord = d.length - 1,\n        str = '',\n        w = d[0];\n\n    if (indexOfLastWord > 0) {\n      str += w;\n\n      for (i = 1; i < indexOfLastWord; i++) {\n        ws = d[i] + '';\n        k = LOG_BASE - ws.length;\n        if (k) str += getZeroString(k);\n        str += ws;\n      }\n\n      w = d[i];\n      ws = w + '';\n      k = LOG_BASE - ws.length;\n      if (k) str += getZeroString(k);\n    } else if (w === 0) {\n      return '0';\n    } // Remove trailing zeros of last w.\n\n\n    for (; w % 10 === 0;) w /= 10;\n\n    return str + w;\n  }\n\n  var divide = function () {\n    // Assumes non-zero x and k, and hence non-zero result.\n    function multiplyInteger(x, k) {\n      var temp,\n          carry = 0,\n          i = x.length;\n\n      for (x = x.slice(); i--;) {\n        temp = x[i] * k + carry;\n        x[i] = temp % BASE | 0;\n        carry = temp / BASE | 0;\n      }\n\n      if (carry) x.unshift(carry);\n      return x;\n    }\n\n    function compare(a, b, aL, bL) {\n      var i, r;\n\n      if (aL != bL) {\n        r = aL > bL ? 1 : -1;\n      } else {\n        for (i = r = 0; i < aL; i++) {\n          if (a[i] != b[i]) {\n            r = a[i] > b[i] ? 1 : -1;\n            break;\n          }\n        }\n      }\n\n      return r;\n    }\n\n    function subtract(a, b, aL) {\n      var i = 0; // Subtract b from a.\n\n      for (; aL--;) {\n        a[aL] -= i;\n        i = a[aL] < b[aL] ? 1 : 0;\n        a[aL] = i * BASE + a[aL] - b[aL];\n      } // Remove leading zeros.\n\n\n      for (; !a[0] && a.length > 1;) a.shift();\n    }\n\n    return function (x, y, pr, dp) {\n      var cmp,\n          e,\n          i,\n          k,\n          prod,\n          prodL,\n          q,\n          qd,\n          rem,\n          remL,\n          rem0,\n          sd,\n          t,\n          xi,\n          xL,\n          yd0,\n          yL,\n          yz,\n          Ctor = x.constructor,\n          sign = x.s == y.s ? 1 : -1,\n          xd = x.d,\n          yd = y.d; // Either 0?\n\n      if (!x.s) return new Ctor(x);\n      if (!y.s) throw Error(decimalError + 'Division by zero');\n      e = x.e - y.e;\n      yL = yd.length;\n      xL = xd.length;\n      q = new Ctor(sign);\n      qd = q.d = []; // Result exponent may be one less than e.\n\n      for (i = 0; yd[i] == (xd[i] || 0);) ++i;\n\n      if (yd[i] > (xd[i] || 0)) --e;\n\n      if (pr == null) {\n        sd = pr = Ctor.precision;\n      } else if (dp) {\n        sd = pr + (getBase10Exponent(x) - getBase10Exponent(y)) + 1;\n      } else {\n        sd = pr;\n      }\n\n      if (sd < 0) return new Ctor(0); // Convert precision in number of base 10 digits to base 1e7 digits.\n\n      sd = sd / LOG_BASE + 2 | 0;\n      i = 0; // divisor < 1e7\n\n      if (yL == 1) {\n        k = 0;\n        yd = yd[0];\n        sd++; // k is the carry.\n\n        for (; (i < xL || k) && sd--; i++) {\n          t = k * BASE + (xd[i] || 0);\n          qd[i] = t / yd | 0;\n          k = t % yd | 0;\n        } // divisor >= 1e7\n\n      } else {\n        // Normalise xd and yd so highest order digit of yd is >= BASE/2\n        k = BASE / (yd[0] + 1) | 0;\n\n        if (k > 1) {\n          yd = multiplyInteger(yd, k);\n          xd = multiplyInteger(xd, k);\n          yL = yd.length;\n          xL = xd.length;\n        }\n\n        xi = yL;\n        rem = xd.slice(0, yL);\n        remL = rem.length; // Add zeros to make remainder as long as divisor.\n\n        for (; remL < yL;) rem[remL++] = 0;\n\n        yz = yd.slice();\n        yz.unshift(0);\n        yd0 = yd[0];\n        if (yd[1] >= BASE / 2) ++yd0;\n\n        do {\n          k = 0; // Compare divisor and remainder.\n\n          cmp = compare(yd, rem, yL, remL); // If divisor < remainder.\n\n          if (cmp < 0) {\n            // Calculate trial digit, k.\n            rem0 = rem[0];\n            if (yL != remL) rem0 = rem0 * BASE + (rem[1] || 0); // k will be how many times the divisor goes into the current remainder.\n\n            k = rem0 / yd0 | 0; //  Algorithm:\n            //  1. product = divisor * trial digit (k)\n            //  2. if product > remainder: product -= divisor, k--\n            //  3. remainder -= product\n            //  4. if product was < remainder at 2:\n            //    5. compare new remainder and divisor\n            //    6. If remainder > divisor: remainder -= divisor, k++\n\n            if (k > 1) {\n              if (k >= BASE) k = BASE - 1; // product = divisor * trial digit.\n\n              prod = multiplyInteger(yd, k);\n              prodL = prod.length;\n              remL = rem.length; // Compare product and remainder.\n\n              cmp = compare(prod, rem, prodL, remL); // product > remainder.\n\n              if (cmp == 1) {\n                k--; // Subtract divisor from product.\n\n                subtract(prod, yL < prodL ? yz : yd, prodL);\n              }\n            } else {\n              // cmp is -1.\n              // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1\n              // to avoid it. If k is 1 there is a need to compare yd and rem again below.\n              if (k == 0) cmp = k = 1;\n              prod = yd.slice();\n            }\n\n            prodL = prod.length;\n            if (prodL < remL) prod.unshift(0); // Subtract product from remainder.\n\n            subtract(rem, prod, remL); // If product was < previous remainder.\n\n            if (cmp == -1) {\n              remL = rem.length; // Compare divisor and new remainder.\n\n              cmp = compare(yd, rem, yL, remL); // If divisor < new remainder, subtract divisor from remainder.\n\n              if (cmp < 1) {\n                k++; // Subtract divisor from remainder.\n\n                subtract(rem, yL < remL ? yz : yd, remL);\n              }\n            }\n\n            remL = rem.length;\n          } else if (cmp === 0) {\n            k++;\n            rem = [0];\n          } // if cmp === 1, k will be 0\n          // Add the next digit, k, to the result array.\n\n\n          qd[i++] = k; // Update the remainder.\n\n          if (cmp && rem[0]) {\n            rem[remL++] = xd[xi] || 0;\n          } else {\n            rem = [xd[xi]];\n            remL = 1;\n          }\n        } while ((xi++ < xL || rem[0] !== void 0) && sd--);\n      } // Leading zero?\n\n\n      if (!qd[0]) qd.shift();\n      q.e = e;\n      return round(q, dp ? pr + getBase10Exponent(q) + 1 : pr);\n    };\n  }();\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of `x` truncated to `sd`\r\n   * significant digits.\r\n   *\r\n   * Taylor/Maclaurin series.\r\n   *\r\n   * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...\r\n   *\r\n   * Argument reduction:\r\n   *   Repeat x = x / 32, k += 5, until |x| < 0.1\r\n   *   exp(x) = exp(x / 2^k)^(2^k)\r\n   *\r\n   * Previously, the argument was initially reduced by\r\n   * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)\r\n   * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was\r\n   * found to be slower than just dividing repeatedly by 32 as above.\r\n   *\r\n   * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)\r\n   *\r\n   *  exp(x) is non-terminating for any finite, non-zero x.\r\n   *\r\n   */\n\n\n  function exp(x, sd) {\n    var denominator,\n        guard,\n        pow,\n        sum,\n        t,\n        wpr,\n        i = 0,\n        k = 0,\n        Ctor = x.constructor,\n        pr = Ctor.precision;\n    if (getBase10Exponent(x) > 16) throw Error(exponentOutOfRange + getBase10Exponent(x)); // exp(0) = 1\n\n    if (!x.s) return new Ctor(ONE);\n\n    if (sd == null) {\n      external = false;\n      wpr = pr;\n    } else {\n      wpr = sd;\n    }\n\n    t = new Ctor(0.03125);\n\n    while (x.abs().gte(0.1)) {\n      x = x.times(t); // x = x / 2^5\n\n      k += 5;\n    } // Estimate the precision increase necessary to ensure the first 4 rounding digits are correct.\n\n\n    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;\n    wpr += guard;\n    denominator = pow = sum = new Ctor(ONE);\n    Ctor.precision = wpr;\n\n    for (;;) {\n      pow = round(pow.times(x), wpr);\n      denominator = denominator.times(++i);\n      t = sum.plus(divide(pow, denominator, wpr));\n\n      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\n        while (k--) sum = round(sum.times(sum), wpr);\n\n        Ctor.precision = pr;\n        return sd == null ? (external = true, round(sum, pr)) : sum;\n      }\n\n      sum = t;\n    }\n  } // Calculate the base 10 exponent from the base 1e7 exponent.\n\n\n  function getBase10Exponent(x) {\n    var e = x.e * LOG_BASE,\n        w = x.d[0]; // Add the number of digits of the first word of the digits array.\n\n    for (; w >= 10; w /= 10) e++;\n\n    return e;\n  }\n\n  function getLn10(Ctor, sd, pr) {\n    if (sd > Ctor.LN10.sd()) {\n      // Reset global state in case the exception is caught.\n      external = true;\n      if (pr) Ctor.precision = pr;\n      throw Error(decimalError + 'LN10 precision limit exceeded');\n    }\n\n    return round(new Ctor(Ctor.LN10), sd);\n  }\n\n  function getZeroString(k) {\n    var zs = '';\n\n    for (; k--;) zs += '0';\n\n    return zs;\n  }\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of `x` truncated to `sd` significant\r\n   * digits.\r\n   *\r\n   *  ln(n) is non-terminating (n != 1)\r\n   *\r\n   */\n\n\n  function ln(y, sd) {\n    var c,\n        c0,\n        denominator,\n        e,\n        numerator,\n        sum,\n        t,\n        wpr,\n        x2,\n        n = 1,\n        guard = 10,\n        x = y,\n        xd = x.d,\n        Ctor = x.constructor,\n        pr = Ctor.precision; // ln(-x) = NaN\n    // ln(0) = -Infinity\n\n    if (x.s < 1) throw Error(decimalError + (x.s ? 'NaN' : '-Infinity')); // ln(1) = 0\n\n    if (x.eq(ONE)) return new Ctor(0);\n\n    if (sd == null) {\n      external = false;\n      wpr = pr;\n    } else {\n      wpr = sd;\n    }\n\n    if (x.eq(10)) {\n      if (sd == null) external = true;\n      return getLn10(Ctor, wpr);\n    }\n\n    wpr += guard;\n    Ctor.precision = wpr;\n    c = digitsToString(xd);\n    c0 = c.charAt(0);\n    e = getBase10Exponent(x);\n\n    if (Math.abs(e) < 1.5e15) {\n      // Argument reduction.\n      // The series converges faster the closer the argument is to 1, so using\n      // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b\n      // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,\n      // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can\n      // later be divided by this number, then separate out the power of 10 using\n      // ln(a*10^b) = ln(a) + b*ln(10).\n      // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).\n      //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {\n      // max n is 6 (gives 0.7 - 1.3)\n      while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {\n        x = x.times(y);\n        c = digitsToString(x.d);\n        c0 = c.charAt(0);\n        n++;\n      }\n\n      e = getBase10Exponent(x);\n\n      if (c0 > 1) {\n        x = new Ctor('0.' + c);\n        e++;\n      } else {\n        x = new Ctor(c0 + '.' + c.slice(1));\n      }\n    } else {\n      // The argument reduction method above may result in overflow if the argument y is a massive\n      // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this\n      // function using ln(x*10^e) = ln(x) + e*ln(10).\n      t = getLn10(Ctor, wpr + 2, pr).times(e + '');\n      x = ln(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);\n      Ctor.precision = pr;\n      return sd == null ? (external = true, round(x, pr)) : x;\n    } // x is reduced to a value near 1.\n    // Taylor series.\n    // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)\n    // where x = (y - 1)/(y + 1)    (|x| < 1)\n\n\n    sum = numerator = x = divide(x.minus(ONE), x.plus(ONE), wpr);\n    x2 = round(x.times(x), wpr);\n    denominator = 3;\n\n    for (;;) {\n      numerator = round(numerator.times(x2), wpr);\n      t = sum.plus(divide(numerator, new Ctor(denominator), wpr));\n\n      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\n        sum = sum.times(2); // Reverse the argument reduction.\n\n        if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));\n        sum = divide(sum, new Ctor(n), wpr);\n        Ctor.precision = pr;\n        return sd == null ? (external = true, round(sum, pr)) : sum;\n      }\n\n      sum = t;\n      denominator += 2;\n    }\n  }\n  /*\r\n   * Parse the value of a new Decimal `x` from string `str`.\r\n   */\n\n\n  function parseDecimal(x, str) {\n    var e, i, len; // Decimal point?\n\n    if ((e = str.indexOf('.')) > -1) str = str.replace('.', ''); // Exponential form?\n\n    if ((i = str.search(/e/i)) > 0) {\n      // Determine exponent.\n      if (e < 0) e = i;\n      e += +str.slice(i + 1);\n      str = str.substring(0, i);\n    } else if (e < 0) {\n      // Integer.\n      e = str.length;\n    } // Determine leading zeros.\n\n\n    for (i = 0; str.charCodeAt(i) === 48;) ++i; // Determine trailing zeros.\n\n\n    for (len = str.length; str.charCodeAt(len - 1) === 48;) --len;\n\n    str = str.slice(i, len);\n\n    if (str) {\n      len -= i;\n      e = e - i - 1;\n      x.e = mathfloor(e / LOG_BASE);\n      x.d = []; // Transform base\n      // e is the base 10 exponent.\n      // i is where to slice str to get the first word of the digits array.\n\n      i = (e + 1) % LOG_BASE;\n      if (e < 0) i += LOG_BASE;\n\n      if (i < len) {\n        if (i) x.d.push(+str.slice(0, i));\n\n        for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));\n\n        str = str.slice(i);\n        i = LOG_BASE - str.length;\n      } else {\n        i -= len;\n      }\n\n      for (; i--;) str += '0';\n\n      x.d.push(+str);\n      if (external && (x.e > MAX_E || x.e < -MAX_E)) throw Error(exponentOutOfRange + e);\n    } else {\n      // Zero.\n      x.s = 0;\n      x.e = 0;\n      x.d = [0];\n    }\n\n    return x;\n  }\n  /*\r\n   * Round `x` to `sd` significant digits, using rounding mode `rm` if present (truncate otherwise).\r\n   */\n\n\n  function round(x, sd, rm) {\n    var i,\n        j,\n        k,\n        n,\n        rd,\n        doRound,\n        w,\n        xdi,\n        xd = x.d; // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.\n    // w: the word of xd which contains the rounding digit, a base 1e7 number.\n    // xdi: the index of w within xd.\n    // n: the number of digits of w.\n    // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if\n    // they had leading zeros)\n    // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).\n    // Get the length of the first word of the digits array xd.\n\n    for (n = 1, k = xd[0]; k >= 10; k /= 10) n++;\n\n    i = sd - n; // Is the rounding digit in the first word of xd?\n\n    if (i < 0) {\n      i += LOG_BASE;\n      j = sd;\n      w = xd[xdi = 0];\n    } else {\n      xdi = Math.ceil((i + 1) / LOG_BASE);\n      k = xd.length;\n      if (xdi >= k) return x;\n      w = k = xd[xdi]; // Get the number of digits of w.\n\n      for (n = 1; k >= 10; k /= 10) n++; // Get the index of rd within w.\n\n\n      i %= LOG_BASE; // Get the index of rd within w, adjusted for leading zeros.\n      // The number of leading zeros of w is given by LOG_BASE - n.\n\n      j = i - LOG_BASE + n;\n    }\n\n    if (rm !== void 0) {\n      k = mathpow(10, n - j - 1); // Get the rounding digit at index j of w.\n\n      rd = w / k % 10 | 0; // Are there any non-zero digits after the rounding digit?\n\n      doRound = sd < 0 || xd[xdi + 1] !== void 0 || w % k; // The expression `w % mathpow(10, n - j - 1)` returns all the digits of w to the right of the\n      // digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression will give\n      // 714.\n\n      doRound = rm < 4 ? (rd || doRound) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || doRound || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.\n      (i > 0 ? j > 0 ? w / mathpow(10, n - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));\n    }\n\n    if (sd < 1 || !xd[0]) {\n      if (doRound) {\n        k = getBase10Exponent(x);\n        xd.length = 1; // Convert sd to decimal places.\n\n        sd = sd - k - 1; // 1, 0.1, 0.01, 0.001, 0.0001 etc.\n\n        xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);\n        x.e = mathfloor(-sd / LOG_BASE) || 0;\n      } else {\n        xd.length = 1; // Zero.\n\n        xd[0] = x.e = x.s = 0;\n      }\n\n      return x;\n    } // Remove excess digits.\n\n\n    if (i == 0) {\n      xd.length = xdi;\n      k = 1;\n      xdi--;\n    } else {\n      xd.length = xdi + 1;\n      k = mathpow(10, LOG_BASE - i); // E.g. 56700 becomes 56000 if 7 is the rounding digit.\n      // j > 0 means i > number of leading zeros of w.\n\n      xd[xdi] = j > 0 ? (w / mathpow(10, n - j) % mathpow(10, j) | 0) * k : 0;\n    }\n\n    if (doRound) {\n      for (;;) {\n        // Is the digit to be rounded up in the first word of xd?\n        if (xdi == 0) {\n          if ((xd[0] += k) == BASE) {\n            xd[0] = 1;\n            ++x.e;\n          }\n\n          break;\n        } else {\n          xd[xdi] += k;\n          if (xd[xdi] != BASE) break;\n          xd[xdi--] = 0;\n          k = 1;\n        }\n      }\n    } // Remove trailing zeros.\n\n\n    for (i = xd.length; xd[--i] === 0;) xd.pop();\n\n    if (external && (x.e > MAX_E || x.e < -MAX_E)) {\n      throw Error(exponentOutOfRange + getBase10Exponent(x));\n    }\n\n    return x;\n  }\n\n  function subtract(x, y) {\n    var d,\n        e,\n        i,\n        j,\n        k,\n        len,\n        xd,\n        xe,\n        xLTy,\n        yd,\n        Ctor = x.constructor,\n        pr = Ctor.precision; // Return y negated if x is zero.\n    // Return x if y is zero and x is non-zero.\n\n    if (!x.s || !y.s) {\n      if (y.s) y.s = -y.s;else y = new Ctor(x);\n      return external ? round(y, pr) : y;\n    }\n\n    xd = x.d;\n    yd = y.d; // x and y are non-zero numbers with the same sign.\n\n    e = y.e;\n    xe = x.e;\n    xd = xd.slice();\n    k = xe - e; // If exponents differ...\n\n    if (k) {\n      xLTy = k < 0;\n\n      if (xLTy) {\n        d = xd;\n        k = -k;\n        len = yd.length;\n      } else {\n        d = yd;\n        e = xe;\n        len = xd.length;\n      } // Numbers with massively different exponents would result in a very high number of zeros\n      // needing to be prepended, but this can be avoided while still ensuring correct rounding by\n      // limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.\n\n\n      i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;\n\n      if (k > i) {\n        k = i;\n        d.length = 1;\n      } // Prepend zeros to equalise exponents.\n\n\n      d.reverse();\n\n      for (i = k; i--;) d.push(0);\n\n      d.reverse(); // Base 1e7 exponents equal.\n    } else {\n      // Check digits to determine which is the bigger number.\n      i = xd.length;\n      len = yd.length;\n      xLTy = i < len;\n      if (xLTy) len = i;\n\n      for (i = 0; i < len; i++) {\n        if (xd[i] != yd[i]) {\n          xLTy = xd[i] < yd[i];\n          break;\n        }\n      }\n\n      k = 0;\n    }\n\n    if (xLTy) {\n      d = xd;\n      xd = yd;\n      yd = d;\n      y.s = -y.s;\n    }\n\n    len = xd.length; // Append zeros to xd if shorter.\n    // Don't add zeros to yd if shorter as subtraction only needs to start at yd length.\n\n    for (i = yd.length - len; i > 0; --i) xd[len++] = 0; // Subtract yd from xd.\n\n\n    for (i = yd.length; i > k;) {\n      if (xd[--i] < yd[i]) {\n        for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;\n\n        --xd[j];\n        xd[i] += BASE;\n      }\n\n      xd[i] -= yd[i];\n    } // Remove trailing zeros.\n\n\n    for (; xd[--len] === 0;) xd.pop(); // Remove leading zeros and adjust exponent accordingly.\n\n\n    for (; xd[0] === 0; xd.shift()) --e; // Zero?\n\n\n    if (!xd[0]) return new Ctor(0);\n    y.d = xd;\n    y.e = e; //return external && xd.length >= pr / LOG_BASE ? round(y, pr) : y;\n\n    return external ? round(y, pr) : y;\n  }\n\n  function toString(x, isExp, sd) {\n    var k,\n        e = getBase10Exponent(x),\n        str = digitsToString(x.d),\n        len = str.length;\n\n    if (isExp) {\n      if (sd && (k = sd - len) > 0) {\n        str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);\n      } else if (len > 1) {\n        str = str.charAt(0) + '.' + str.slice(1);\n      }\n\n      str = str + (e < 0 ? 'e' : 'e+') + e;\n    } else if (e < 0) {\n      str = '0.' + getZeroString(-e - 1) + str;\n      if (sd && (k = sd - len) > 0) str += getZeroString(k);\n    } else if (e >= len) {\n      str += getZeroString(e + 1 - len);\n      if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);\n    } else {\n      if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);\n\n      if (sd && (k = sd - len) > 0) {\n        if (e + 1 === len) str += '.';\n        str += getZeroString(k);\n      }\n    }\n\n    return x.s < 0 ? '-' + str : str;\n  } // Does not strip trailing zeros.\n\n\n  function truncate(arr, len) {\n    if (arr.length > len) {\n      arr.length = len;\n      return true;\n    }\n  } // Decimal methods\n\n  /*\r\n   *  clone\r\n   *  config/set\r\n   */\n\n  /*\r\n   * Create and return a Decimal constructor with the same configuration properties as this Decimal\r\n   * constructor.\r\n   *\r\n   */\n\n\n  function clone(obj) {\n    var i, p, ps;\n    /*\r\n     * The Decimal constructor and exported function.\r\n     * Return a new Decimal instance.\r\n     *\r\n     * value {number|string|Decimal} A numeric value.\r\n     *\r\n     */\n\n    function Decimal(value) {\n      var x = this; // Decimal called without new.\n\n      if (!(x instanceof Decimal)) return new Decimal(value); // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor\n      // which points to Object.\n\n      x.constructor = Decimal; // Duplicate.\n\n      if (value instanceof Decimal) {\n        x.s = value.s;\n        x.e = value.e;\n        x.d = (value = value.d) ? value.slice() : value;\n        return;\n      }\n\n      if (typeof value === 'number') {\n        // Reject Infinity/NaN.\n        if (value * 0 !== 0) {\n          throw Error(invalidArgument + value);\n        }\n\n        if (value > 0) {\n          x.s = 1;\n        } else if (value < 0) {\n          value = -value;\n          x.s = -1;\n        } else {\n          x.s = 0;\n          x.e = 0;\n          x.d = [0];\n          return;\n        } // Fast path for small integers.\n\n\n        if (value === ~~value && value < 1e7) {\n          x.e = 0;\n          x.d = [value];\n          return;\n        }\n\n        return parseDecimal(x, value.toString());\n      } else if (typeof value !== 'string') {\n        throw Error(invalidArgument + value);\n      } // Minus sign?\n\n\n      if (value.charCodeAt(0) === 45) {\n        value = value.slice(1);\n        x.s = -1;\n      } else {\n        x.s = 1;\n      }\n\n      if (isDecimal.test(value)) parseDecimal(x, value);else throw Error(invalidArgument + value);\n    }\n\n    Decimal.prototype = P;\n    Decimal.ROUND_UP = 0;\n    Decimal.ROUND_DOWN = 1;\n    Decimal.ROUND_CEIL = 2;\n    Decimal.ROUND_FLOOR = 3;\n    Decimal.ROUND_HALF_UP = 4;\n    Decimal.ROUND_HALF_DOWN = 5;\n    Decimal.ROUND_HALF_EVEN = 6;\n    Decimal.ROUND_HALF_CEIL = 7;\n    Decimal.ROUND_HALF_FLOOR = 8;\n    Decimal.clone = clone;\n    Decimal.config = Decimal.set = config;\n    if (obj === void 0) obj = {};\n\n    if (obj) {\n      ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'LN10'];\n\n      for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];\n    }\n\n    Decimal.config(obj);\n    return Decimal;\n  }\n  /*\r\n   * Configure global settings for a Decimal constructor.\r\n   *\r\n   * `obj` is an object with one or more of the following properties,\r\n   *\r\n   *   precision  {number}\r\n   *   rounding   {number}\r\n   *   toExpNeg   {number}\r\n   *   toExpPos   {number}\r\n   *\r\n   * E.g. Decimal.config({ precision: 20, rounding: 4 })\r\n   *\r\n   */\n\n\n  function config(obj) {\n    if (!obj || typeof obj !== 'object') {\n      throw Error(decimalError + 'Object expected');\n    }\n\n    var i,\n        p,\n        v,\n        ps = ['precision', 1, MAX_DIGITS, 'rounding', 0, 8, 'toExpNeg', -1 / 0, 0, 'toExpPos', 0, 1 / 0];\n\n    for (i = 0; i < ps.length; i += 3) {\n      if ((v = obj[p = ps[i]]) !== void 0) {\n        if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;else throw Error(invalidArgument + p + ': ' + v);\n      }\n    }\n\n    if ((v = obj[p = 'LN10']) !== void 0) {\n      if (v == Math.LN10) this[p] = new this(v);else throw Error(invalidArgument + p + ': ' + v);\n    }\n\n    return this;\n  } // Create and configure initial Decimal constructor.\n\n\n  Decimal = clone(Decimal);\n  Decimal['default'] = Decimal.Decimal = Decimal; // Internal constant.\n\n  ONE = new Decimal(1); // Export.\n  // AMD.\n\n  if (typeof define == 'function' && define.amd) {\n    define(function () {\n      return Decimal;\n    }); // Node and other environments that support module.exports.\n  } else if (typeof module != 'undefined' && module.exports) {\n    module.exports = Decimal; // Browser.\n  } else {\n    if (!globalScope) {\n      globalScope = typeof self != 'undefined' && self && self.self == self ? self : Function('return this')();\n    }\n\n    globalScope.Decimal = Decimal;\n  }\n})(this);","map":{"version":3,"sources":["/usr/share/pgn-chess/node_modules/decimal.js-light/decimal.js"],"names":["globalScope","MAX_DIGITS","Decimal","precision","rounding","toExpNeg","toExpPos","LN10","external","decimalError","invalidArgument","exponentOutOfRange","mathfloor","Math","floor","mathpow","pow","isDecimal","ONE","BASE","LOG_BASE","MAX_SAFE_INTEGER","MAX_E","P","absoluteValue","abs","x","constructor","s","comparedTo","cmp","y","i","j","xdL","ydL","e","d","length","decimalPlaces","dp","w","dividedBy","div","divide","dividedToIntegerBy","idiv","Ctor","round","equals","eq","exponent","getBase10Exponent","greaterThan","gt","greaterThanOrEqualTo","gte","isInteger","isint","isNegative","isneg","isPositive","ispos","isZero","lessThan","lt","lessThanOrEqualTo","lte","logarithm","log","base","r","pr","wpr","Error","ln","minus","sub","subtract","add","modulo","mod","q","times","naturalExponential","exp","naturalLogarithm","negated","neg","plus","sd","z","squareRoot","sqrt","n","t","digitsToString","toExponential","slice","indexOf","toString","mul","carry","k","rL","xd","yd","push","pop","shift","toDecimalPlaces","todp","rm","checkInt32","str","toFixed","toInteger","toint","toNumber","toPower","sign","yIsInt","guard","yn","ceil","truncate","max","toPrecision","toSignificantDigits","tosd","valueOf","val","toJSON","len","reverse","unshift","min","ws","indexOfLastWord","getZeroString","multiplyInteger","temp","compare","a","b","aL","bL","prod","prodL","qd","rem","remL","rem0","xi","xL","yd0","yL","yz","denominator","sum","getLn10","zs","c","c0","numerator","x2","charAt","parseDecimal","replace","search","substring","charCodeAt","rd","doRound","xdi","xe","xLTy","isExp","arr","clone","obj","p","ps","value","test","prototype","ROUND_UP","ROUND_DOWN","ROUND_CEIL","ROUND_FLOOR","ROUND_HALF_UP","ROUND_HALF_DOWN","ROUND_HALF_EVEN","ROUND_HALF_CEIL","ROUND_HALF_FLOOR","config","set","hasOwnProperty","v","define","amd","module","exports","self","Function"],"mappings":"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","sourcesContent":["/*! decimal.js-light v2.5.0 https://github.com/MikeMcl/decimal.js-light/LICENCE */\r\n;(function (globalScope) {\r\n  'use strict';\r\n\r\n\r\n  /*\r\n   *  decimal.js-light v2.5.0\r\n   *  An arbitrary-precision Decimal type for JavaScript.\r\n   *  https://github.com/MikeMcl/decimal.js-light\r\n   *  Copyright (c) 2018 Michael Mclaughlin <M8ch88l@gmail.com>\r\n   *  MIT Expat Licence\r\n   */\r\n\r\n\r\n  // -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //\r\n\r\n\r\n    // The limit on the value of `precision`, and on the value of the first argument to\r\n    // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.\r\n  var MAX_DIGITS = 1e9,                        // 0 to 1e9\r\n\r\n\r\n    // The initial configuration properties of the Decimal constructor.\r\n    Decimal = {\r\n\r\n      // These values must be integers within the stated ranges (inclusive).\r\n      // Most of these values can be changed during run-time using `Decimal.config`.\r\n\r\n      // The maximum number of significant digits of the result of a calculation or base conversion.\r\n      // E.g. `Decimal.config({ precision: 20 });`\r\n      precision: 20,                         // 1 to MAX_DIGITS\r\n\r\n      // The rounding mode used by default by `toInteger`, `toDecimalPlaces`, `toExponential`,\r\n      // `toFixed`, `toPrecision` and `toSignificantDigits`.\r\n      //\r\n      // ROUND_UP         0 Away from zero.\r\n      // ROUND_DOWN       1 Towards zero.\r\n      // ROUND_CEIL       2 Towards +Infinity.\r\n      // ROUND_FLOOR      3 Towards -Infinity.\r\n      // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n      // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n      // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n      // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n      // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n      //\r\n      // E.g.\r\n      // `Decimal.rounding = 4;`\r\n      // `Decimal.rounding = Decimal.ROUND_HALF_UP;`\r\n      rounding: 4,                           // 0 to 8\r\n\r\n      // The exponent value at and beneath which `toString` returns exponential notation.\r\n      // JavaScript numbers: -7\r\n      toExpNeg: -7,                          // 0 to -MAX_E\r\n\r\n      // The exponent value at and above which `toString` returns exponential notation.\r\n      // JavaScript numbers: 21\r\n      toExpPos:  21,                         // 0 to MAX_E\r\n\r\n      // The natural logarithm of 10.\r\n      // 115 digits\r\n      LN10: '2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286'\r\n    },\r\n\r\n\r\n  // ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //\r\n\r\n\r\n    external = true,\r\n\r\n    decimalError = '[DecimalError] ',\r\n    invalidArgument = decimalError + 'Invalid argument: ',\r\n    exponentOutOfRange = decimalError + 'Exponent out of range: ',\r\n\r\n    mathfloor = Math.floor,\r\n    mathpow = Math.pow,\r\n\r\n    isDecimal = /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i,\r\n\r\n    ONE,\r\n    BASE = 1e7,\r\n    LOG_BASE = 7,\r\n    MAX_SAFE_INTEGER = 9007199254740991,\r\n    MAX_E = mathfloor(MAX_SAFE_INTEGER / LOG_BASE),    // 1286742750677284\r\n\r\n    // Decimal.prototype object\r\n    P = {};\r\n\r\n\r\n  // Decimal prototype methods\r\n\r\n\r\n  /*\r\n   *  absoluteValue                       abs\r\n   *  comparedTo                          cmp\r\n   *  decimalPlaces                       dp\r\n   *  dividedBy                           div\r\n   *  dividedToIntegerBy                  idiv\r\n   *  equals                              eq\r\n   *  exponent\r\n   *  greaterThan                         gt\r\n   *  greaterThanOrEqualTo                gte\r\n   *  isInteger                           isint\r\n   *  isNegative                          isneg\r\n   *  isPositive                          ispos\r\n   *  isZero\r\n   *  lessThan                            lt\r\n   *  lessThanOrEqualTo                   lte\r\n   *  logarithm                           log\r\n   *  minus                               sub\r\n   *  modulo                              mod\r\n   *  naturalExponential                  exp\r\n   *  naturalLogarithm                    ln\r\n   *  negated                             neg\r\n   *  plus                                add\r\n   *  precision                           sd\r\n   *  squareRoot                          sqrt\r\n   *  times                               mul\r\n   *  toDecimalPlaces                     todp\r\n   *  toExponential\r\n   *  toFixed\r\n   *  toInteger                           toint\r\n   *  toNumber\r\n   *  toPower                             pow\r\n   *  toPrecision\r\n   *  toSignificantDigits                 tosd\r\n   *  toString\r\n   *  valueOf                             val\r\n   */\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the absolute value of this Decimal.\r\n   *\r\n   */\r\n  P.absoluteValue = P.abs = function () {\r\n    var x = new this.constructor(this);\r\n    if (x.s) x.s = 1;\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return\r\n   *   1    if the value of this Decimal is greater than the value of `y`,\r\n   *  -1    if the value of this Decimal is less than the value of `y`,\r\n   *   0    if they have the same value\r\n   *\r\n   */\r\n  P.comparedTo = P.cmp = function (y) {\r\n    var i, j, xdL, ydL,\r\n      x = this;\r\n\r\n    y = new x.constructor(y);\r\n\r\n    // Signs differ?\r\n    if (x.s !== y.s) return x.s || -y.s;\r\n\r\n    // Compare exponents.\r\n    if (x.e !== y.e) return x.e > y.e ^ x.s < 0 ? 1 : -1;\r\n\r\n    xdL = x.d.length;\r\n    ydL = y.d.length;\r\n\r\n    // Compare digit by digit.\r\n    for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {\r\n      if (x.d[i] !== y.d[i]) return x.d[i] > y.d[i] ^ x.s < 0 ? 1 : -1;\r\n    }\r\n\r\n    // Compare lengths.\r\n    return xdL === ydL ? 0 : xdL > ydL ^ x.s < 0 ? 1 : -1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the number of decimal places of the value of this Decimal.\r\n   *\r\n   */\r\n  P.decimalPlaces = P.dp = function () {\r\n    var x = this,\r\n      w = x.d.length - 1,\r\n      dp = (w - x.e) * LOG_BASE;\r\n\r\n    // Subtract the number of trailing zeros of the last word.\r\n    w = x.d[w];\r\n    if (w) for (; w % 10 == 0; w /= 10) dp--;\r\n\r\n    return dp < 0 ? 0 : dp;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal divided by `y`, truncated to\r\n   * `precision` significant digits.\r\n   *\r\n   */\r\n  P.dividedBy = P.div = function (y) {\r\n    return divide(this, new this.constructor(y));\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the integer part of dividing the value of this Decimal\r\n   * by the value of `y`, truncated to `precision` significant digits.\r\n   *\r\n   */\r\n  P.dividedToIntegerBy = P.idiv = function (y) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n    return round(divide(x, new Ctor(y), 0, 1), Ctor.precision);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.\r\n   *\r\n   */\r\n  P.equals = P.eq = function (y) {\r\n    return !this.cmp(y);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the (base 10) exponent value of this Decimal (this.e is the base 10000000 exponent).\r\n   *\r\n   */\r\n  P.exponent = function () {\r\n    return getBase10Exponent(this);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is greater than the value of `y`, otherwise return\r\n   * false.\r\n   *\r\n   */\r\n  P.greaterThan = P.gt = function (y) {\r\n    return this.cmp(y) > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is greater than or equal to the value of `y`,\r\n   * otherwise return false.\r\n   *\r\n   */\r\n  P.greaterThanOrEqualTo = P.gte = function (y) {\r\n    return this.cmp(y) >= 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is an integer, otherwise return false.\r\n   *\r\n   */\r\n  P.isInteger = P.isint = function () {\r\n    return this.e > this.d.length - 2;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is negative, otherwise return false.\r\n   *\r\n   */\r\n  P.isNegative = P.isneg = function () {\r\n    return this.s < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is positive, otherwise return false.\r\n   *\r\n   */\r\n  P.isPositive = P.ispos = function () {\r\n    return this.s > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is 0, otherwise return false.\r\n   *\r\n   */\r\n  P.isZero = function () {\r\n    return this.s === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is less than `y`, otherwise return false.\r\n   *\r\n   */\r\n  P.lessThan = P.lt = function (y) {\r\n    return this.cmp(y) < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.\r\n   *\r\n   */\r\n  P.lessThanOrEqualTo = P.lte = function (y) {\r\n    return this.cmp(y) < 1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the logarithm of the value of this Decimal to the specified base, truncated to\r\n   * `precision` significant digits.\r\n   *\r\n   * If no base is specified, return log[10](x).\r\n   *\r\n   * log[base](x) = ln(x) / ln(base)\r\n   *\r\n   * The maximum error of the result is 1 ulp (unit in the last place).\r\n   *\r\n   * [base] {number|string|Decimal} The base of the logarithm.\r\n   *\r\n   */\r\n  P.logarithm = P.log = function (base) {\r\n    var r,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      pr = Ctor.precision,\r\n      wpr = pr + 5;\r\n\r\n    // Default base is 10.\r\n    if (base === void 0) {\r\n      base = new Ctor(10);\r\n    } else {\r\n      base = new Ctor(base);\r\n\r\n      // log[-b](x) = NaN\r\n      // log[0](x)  = NaN\r\n      // log[1](x)  = NaN\r\n      if (base.s < 1 || base.eq(ONE)) throw Error(decimalError + 'NaN');\r\n    }\r\n\r\n    // log[b](-x) = NaN\r\n    // log[b](0) = -Infinity\r\n    if (x.s < 1) throw Error(decimalError + (x.s ? 'NaN' : '-Infinity'));\r\n\r\n    // log[b](1) = 0\r\n    if (x.eq(ONE)) return new Ctor(0);\r\n\r\n    external = false;\r\n    r = divide(ln(x, wpr), ln(base, wpr), wpr);\r\n    external = true;\r\n\r\n    return round(r, pr);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal minus `y`, truncated to\r\n   * `precision` significant digits.\r\n   *\r\n   */\r\n  P.minus = P.sub = function (y) {\r\n    var x = this;\r\n    y = new x.constructor(y);\r\n    return x.s == y.s ? subtract(x, y) : add(x, (y.s = -y.s, y));\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal modulo `y`, truncated to\r\n   * `precision` significant digits.\r\n   *\r\n   */\r\n  P.modulo = P.mod = function (y) {\r\n    var q,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      pr = Ctor.precision;\r\n\r\n    y = new Ctor(y);\r\n\r\n    // x % 0 = NaN\r\n    if (!y.s) throw Error(decimalError + 'NaN');\r\n\r\n    // Return x if x is 0.\r\n    if (!x.s) return round(new Ctor(x), pr);\r\n\r\n    // Prevent rounding of intermediate calculations.\r\n    external = false;\r\n    q = divide(x, y, 0, 1).times(y);\r\n    external = true;\r\n\r\n    return x.minus(q);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of the value of this Decimal,\r\n   * i.e. the base e raised to the power the value of this Decimal, truncated to `precision`\r\n   * significant digits.\r\n   *\r\n   */\r\n  P.naturalExponential = P.exp = function () {\r\n    return exp(this);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,\r\n   * truncated to `precision` significant digits.\r\n   *\r\n   */\r\n  P.naturalLogarithm = P.ln = function () {\r\n    return ln(this);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by\r\n   * -1.\r\n   *\r\n   */\r\n  P.negated = P.neg = function () {\r\n    var x = new this.constructor(this);\r\n    x.s = -x.s || 0;\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal plus `y`, truncated to\r\n   * `precision` significant digits.\r\n   *\r\n   */\r\n  P.plus = P.add = function (y) {\r\n    var x = this;\r\n    y = new x.constructor(y);\r\n    return x.s == y.s ? add(x, y) : subtract(x, (y.s = -y.s, y));\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the number of significant digits of the value of this Decimal.\r\n   *\r\n   * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.\r\n   *\r\n   */\r\n  P.precision = P.sd = function (z) {\r\n    var e, sd, w,\r\n      x = this;\r\n\r\n    if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);\r\n\r\n    e = getBase10Exponent(x) + 1;\r\n    w = x.d.length - 1;\r\n    sd = w * LOG_BASE + 1;\r\n    w = x.d[w];\r\n\r\n    // If non-zero...\r\n    if (w) {\r\n\r\n      // Subtract the number of trailing zeros of the last word.\r\n      for (; w % 10 == 0; w /= 10) sd--;\r\n\r\n      // Add the number of digits of the first word.\r\n      for (w = x.d[0]; w >= 10; w /= 10) sd++;\r\n    }\r\n\r\n    return z && e > sd ? e : sd;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the square root of this Decimal, truncated to `precision`\r\n   * significant digits.\r\n   *\r\n   */\r\n  P.squareRoot = P.sqrt = function () {\r\n    var e, n, pr, r, s, t, wpr,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    // Negative or zero?\r\n    if (x.s < 1) {\r\n      if (!x.s) return new Ctor(0);\r\n\r\n      // sqrt(-x) = NaN\r\n      throw Error(decimalError + 'NaN');\r\n    }\r\n\r\n    e = getBase10Exponent(x);\r\n    external = false;\r\n\r\n    // Initial estimate.\r\n    s = Math.sqrt(+x);\r\n\r\n    // Math.sqrt underflow/overflow?\r\n    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n    if (s == 0 || s == 1 / 0) {\r\n      n = digitsToString(x.d);\r\n      if ((n.length + e) % 2 == 0) n += '0';\r\n      s = Math.sqrt(n);\r\n      e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n      if (s == 1 / 0) {\r\n        n = '1e' + e;\r\n      } else {\r\n        n = s.toExponential();\r\n        n = n.slice(0, n.indexOf('e') + 1) + e;\r\n      }\r\n\r\n      r = new Ctor(n);\r\n    } else {\r\n      r = new Ctor(s.toString());\r\n    }\r\n\r\n    pr = Ctor.precision;\r\n    s = wpr = pr + 3;\r\n\r\n    // Newton-Raphson iteration.\r\n    for (;;) {\r\n      t = r;\r\n      r = t.plus(divide(x, t, wpr + 2)).times(0.5);\r\n\r\n      if (digitsToString(t.d).slice(0, wpr) === (n = digitsToString(r.d)).slice(0, wpr)) {\r\n        n = n.slice(wpr - 3, wpr + 1);\r\n\r\n        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or\r\n        // 4999, i.e. approaching a rounding boundary, continue the iteration.\r\n        if (s == wpr && n == '4999') {\r\n\r\n          // On the first iteration only, check to see if rounding up gives the exact result as the\r\n          // nines may infinitely repeat.\r\n          round(t, pr + 1, 0);\r\n\r\n          if (t.times(t).eq(x)) {\r\n            r = t;\r\n            break;\r\n          }\r\n        } else if (n != '9999') {\r\n          break;\r\n        }\r\n\r\n        wpr += 4;\r\n      }\r\n    }\r\n\r\n    external = true;\r\n\r\n    return round(r, pr);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal times `y`, truncated to\r\n   * `precision` significant digits.\r\n   *\r\n   */\r\n  P.times = P.mul = function (y) {\r\n    var carry, e, i, k, r, rL, t, xdL, ydL,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      xd = x.d,\r\n      yd = (y = new Ctor(y)).d;\r\n\r\n    // Return 0 if either is 0.\r\n    if (!x.s || !y.s) return new Ctor(0);\r\n\r\n    y.s *= x.s;\r\n    e = x.e + y.e;\r\n    xdL = xd.length;\r\n    ydL = yd.length;\r\n\r\n    // Ensure xd points to the longer array.\r\n    if (xdL < ydL) {\r\n      r = xd;\r\n      xd = yd;\r\n      yd = r;\r\n      rL = xdL;\r\n      xdL = ydL;\r\n      ydL = rL;\r\n    }\r\n\r\n    // Initialise the result array with zeros.\r\n    r = [];\r\n    rL = xdL + ydL;\r\n    for (i = rL; i--;) r.push(0);\r\n\r\n    // Multiply!\r\n    for (i = ydL; --i >= 0;) {\r\n      carry = 0;\r\n      for (k = xdL + i; k > i;) {\r\n        t = r[k] + yd[i] * xd[k - i - 1] + carry;\r\n        r[k--] = t % BASE | 0;\r\n        carry = t / BASE | 0;\r\n      }\r\n\r\n      r[k] = (r[k] + carry) % BASE | 0;\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (; !r[--rL];) r.pop();\r\n\r\n    if (carry) ++e;\r\n    else r.shift();\r\n\r\n    y.d = r;\r\n    y.e = e;\r\n\r\n    return external ? round(y, Ctor.precision) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`\r\n   * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.\r\n   *\r\n   * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toDecimalPlaces = P.todp = function (dp, rm) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    x = new Ctor(x);\r\n    if (dp === void 0) return x;\r\n\r\n    checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n    if (rm === void 0) rm = Ctor.rounding;\r\n    else checkInt32(rm, 0, 8);\r\n\r\n    return round(x, dp + getBase10Exponent(x) + 1, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in exponential notation rounded to\r\n   * `dp` fixed decimal places using rounding mode `rounding`.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toExponential = function (dp, rm) {\r\n    var str,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (dp === void 0) {\r\n      str = toString(x, true);\r\n    } else {\r\n      checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n\r\n      x = round(new Ctor(x), dp + 1, rm);\r\n      str = toString(x, true, dp + 1);\r\n    }\r\n\r\n    return str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in normal (fixed-point) notation to\r\n   * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is\r\n   * omitted.\r\n   *\r\n   * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\r\n   * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n   * (-0).toFixed(3) is '0.000'.\r\n   * (-0.5).toFixed(0) is '-0'.\r\n   *\r\n   */\r\n  P.toFixed = function (dp, rm) {\r\n    var str, y,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (dp === void 0) return toString(x);\r\n\r\n    checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n    if (rm === void 0) rm = Ctor.rounding;\r\n    else checkInt32(rm, 0, 8);\r\n\r\n    y = round(new Ctor(x), dp + getBase10Exponent(x) + 1, rm);\r\n    str = toString(y.abs(), false, dp + getBase10Exponent(y) + 1);\r\n\r\n    // To determine whether to add the minus sign look at the value before it was rounded,\r\n    // i.e. look at `x` rather than `y`.\r\n    return x.isneg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using\r\n   * rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.toInteger = P.toint = function () {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n    return round(new Ctor(x), getBase10Exponent(x) + 1, Ctor.rounding);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the value of this Decimal converted to a number primitive.\r\n   *\r\n   */\r\n  P.toNumber = function () {\r\n    return +this;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal raised to the power `y`,\r\n   * truncated to `precision` significant digits.\r\n   *\r\n   * For non-integer or very large exponents pow(x, y) is calculated using\r\n   *\r\n   *   x^y = exp(y*ln(x))\r\n   *\r\n   * The maximum error is 1 ulp (unit in last place).\r\n   *\r\n   * y {number|string|Decimal} The power to which to raise this Decimal.\r\n   *\r\n   */\r\n  P.toPower = P.pow = function (y) {\r\n    var e, k, pr, r, sign, yIsInt,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      guard = 12,\r\n      yn = +(y = new Ctor(y));\r\n\r\n    // pow(x, 0) = 1\r\n    if (!y.s) return new Ctor(ONE);\r\n\r\n    x = new Ctor(x);\r\n\r\n    // pow(0, y > 0) = 0\r\n    // pow(0, y < 0) = Infinity\r\n    if (!x.s) {\r\n      if (y.s < 1) throw Error(decimalError + 'Infinity');\r\n      return x;\r\n    }\r\n\r\n    // pow(1, y) = 1\r\n    if (x.eq(ONE)) return x;\r\n\r\n    pr = Ctor.precision;\r\n\r\n    // pow(x, 1) = x\r\n    if (y.eq(ONE)) return round(x, pr);\r\n\r\n    e = y.e;\r\n    k = y.d.length - 1;\r\n    yIsInt = e >= k;\r\n    sign = x.s;\r\n\r\n    if (!yIsInt) {\r\n\r\n      // pow(x < 0, y non-integer) = NaN\r\n      if (sign < 0) throw Error(decimalError + 'NaN');\r\n\r\n    // If y is a small integer use the 'exponentiation by squaring' algorithm.\r\n    } else if ((k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {\r\n      r = new Ctor(ONE);\r\n\r\n      // Max k of 9007199254740991 takes 53 loop iterations.\r\n      // Maximum digits array length; leaves [28, 34] guard digits.\r\n      e = Math.ceil(pr / LOG_BASE + 4);\r\n\r\n      external = false;\r\n\r\n      for (;;) {\r\n        if (k % 2) {\r\n          r = r.times(x);\r\n          truncate(r.d, e);\r\n        }\r\n\r\n        k = mathfloor(k / 2);\r\n        if (k === 0) break;\r\n\r\n        x = x.times(x);\r\n        truncate(x.d, e);\r\n      }\r\n\r\n      external = true;\r\n\r\n      return y.s < 0 ? new Ctor(ONE).div(r) : round(r, pr);\r\n    }\r\n\r\n    // Result is negative if x is negative and the last digit of integer y is odd.\r\n    sign = sign < 0 && y.d[Math.max(e, k)] & 1 ? -1 : 1;\r\n\r\n    x.s = 1;\r\n    external = false;\r\n    r = y.times(ln(x, pr + guard));\r\n    external = true;\r\n    r = exp(r);\r\n    r.s = sign;\r\n\r\n    return r;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal rounded to `sd` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * Return exponential notation if `sd` is less than the number of digits necessary to represent\r\n   * the integer part of the value in normal notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toPrecision = function (sd, rm) {\r\n    var e, str,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (sd === void 0) {\r\n      e = getBase10Exponent(x);\r\n      str = toString(x, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);\r\n    } else {\r\n      checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n\r\n      x = round(new Ctor(x), sd, rm);\r\n      e = getBase10Exponent(x);\r\n      str = toString(x, sd <= e || e <= Ctor.toExpNeg, sd);\r\n    }\r\n\r\n    return str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`\r\n   * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if\r\n   * omitted.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toSignificantDigits = P.tosd = function (sd, rm) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (sd === void 0) {\r\n      sd = Ctor.precision;\r\n      rm = Ctor.rounding;\r\n    } else {\r\n      checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n    }\r\n\r\n    return round(new Ctor(x), sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal.\r\n   *\r\n   * Return exponential notation if this Decimal has a positive exponent equal to or greater than\r\n   * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.\r\n   *\r\n   */\r\n  P.toString = P.valueOf = P.val = P.toJSON = function () {\r\n    var x = this,\r\n      e = getBase10Exponent(x),\r\n      Ctor = x.constructor;\r\n\r\n    return toString(x, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);\r\n  };\r\n\r\n\r\n  // Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.\r\n\r\n\r\n  /*\r\n   *  add                 P.minus, P.plus\r\n   *  checkInt32          P.todp, P.toExponential, P.toFixed, P.toPrecision, P.tosd\r\n   *  digitsToString      P.log, P.sqrt, P.pow, toString, exp, ln\r\n   *  divide              P.div, P.idiv, P.log, P.mod, P.sqrt, exp, ln\r\n   *  exp                 P.exp, P.pow\r\n   *  getBase10Exponent   P.exponent, P.sd, P.toint, P.sqrt, P.todp, P.toFixed, P.toPrecision,\r\n   *                      P.toString, divide, round, toString, exp, ln\r\n   *  getLn10             P.log, ln\r\n   *  getZeroString       digitsToString, toString\r\n   *  ln                  P.log, P.ln, P.pow, exp\r\n   *  parseDecimal        Decimal\r\n   *  round               P.abs, P.idiv, P.log, P.minus, P.mod, P.neg, P.plus, P.toint, P.sqrt,\r\n   *                      P.times, P.todp, P.toExponential, P.toFixed, P.pow, P.toPrecision, P.tosd,\r\n   *                      divide, getLn10, exp, ln\r\n   *  subtract            P.minus, P.plus\r\n   *  toString            P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf\r\n   *  truncate            P.pow\r\n   *\r\n   *  Throws:             P.log, P.mod, P.sd, P.sqrt, P.pow,  checkInt32, divide, round,\r\n   *                      getLn10, exp, ln, parseDecimal, Decimal, config\r\n   */\r\n\r\n\r\n  function add(x, y) {\r\n    var carry, d, e, i, k, len, xd, yd,\r\n      Ctor = x.constructor,\r\n      pr = Ctor.precision;\r\n\r\n    // If either is zero...\r\n    if (!x.s || !y.s) {\r\n\r\n      // Return x if y is zero.\r\n      // Return y if y is non-zero.\r\n      if (!y.s) y = new Ctor(x);\r\n      return external ? round(y, pr) : y;\r\n    }\r\n\r\n    xd = x.d;\r\n    yd = y.d;\r\n\r\n    // x and y are finite, non-zero numbers with the same sign.\r\n\r\n    k = x.e;\r\n    e = y.e;\r\n    xd = xd.slice();\r\n    i = k - e;\r\n\r\n    // If base 1e7 exponents differ...\r\n    if (i) {\r\n      if (i < 0) {\r\n        d = xd;\r\n        i = -i;\r\n        len = yd.length;\r\n      } else {\r\n        d = yd;\r\n        e = k;\r\n        len = xd.length;\r\n      }\r\n\r\n      // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.\r\n      k = Math.ceil(pr / LOG_BASE);\r\n      len = k > len ? k + 1 : len + 1;\r\n\r\n      if (i > len) {\r\n        i = len;\r\n        d.length = 1;\r\n      }\r\n\r\n      // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.\r\n      d.reverse();\r\n      for (; i--;) d.push(0);\r\n      d.reverse();\r\n    }\r\n\r\n    len = xd.length;\r\n    i = yd.length;\r\n\r\n    // If yd is longer than xd, swap xd and yd so xd points to the longer array.\r\n    if (len - i < 0) {\r\n      i = len;\r\n      d = yd;\r\n      yd = xd;\r\n      xd = d;\r\n    }\r\n\r\n    // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.\r\n    for (carry = 0; i;) {\r\n      carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;\r\n      xd[i] %= BASE;\r\n    }\r\n\r\n    if (carry) {\r\n      xd.unshift(carry);\r\n      ++e;\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n    for (len = xd.length; xd[--len] == 0;) xd.pop();\r\n\r\n    y.d = xd;\r\n    y.e = e;\r\n\r\n    return external ? round(y, pr) : y;\r\n  }\r\n\r\n\r\n  function checkInt32(i, min, max) {\r\n    if (i !== ~~i || i < min || i > max) {\r\n      throw Error(invalidArgument + i);\r\n    }\r\n  }\r\n\r\n\r\n  function digitsToString(d) {\r\n    var i, k, ws,\r\n      indexOfLastWord = d.length - 1,\r\n      str = '',\r\n      w = d[0];\r\n\r\n    if (indexOfLastWord > 0) {\r\n      str += w;\r\n      for (i = 1; i < indexOfLastWord; i++) {\r\n        ws = d[i] + '';\r\n        k = LOG_BASE - ws.length;\r\n        if (k) str += getZeroString(k);\r\n        str += ws;\r\n      }\r\n\r\n      w = d[i];\r\n      ws = w + '';\r\n      k = LOG_BASE - ws.length;\r\n      if (k) str += getZeroString(k);\r\n    } else if (w === 0) {\r\n      return '0';\r\n    }\r\n\r\n    // Remove trailing zeros of last w.\r\n    for (; w % 10 === 0;) w /= 10;\r\n\r\n    return str + w;\r\n  }\r\n\r\n\r\n  var divide = (function () {\r\n\r\n    // Assumes non-zero x and k, and hence non-zero result.\r\n    function multiplyInteger(x, k) {\r\n      var temp,\r\n        carry = 0,\r\n        i = x.length;\r\n\r\n      for (x = x.slice(); i--;) {\r\n        temp = x[i] * k + carry;\r\n        x[i] = temp % BASE | 0;\r\n        carry = temp / BASE | 0;\r\n      }\r\n\r\n      if (carry) x.unshift(carry);\r\n\r\n      return x;\r\n    }\r\n\r\n    function compare(a, b, aL, bL) {\r\n      var i, r;\r\n\r\n      if (aL != bL) {\r\n        r = aL > bL ? 1 : -1;\r\n      } else {\r\n        for (i = r = 0; i < aL; i++) {\r\n          if (a[i] != b[i]) {\r\n            r = a[i] > b[i] ? 1 : -1;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      return r;\r\n    }\r\n\r\n    function subtract(a, b, aL) {\r\n      var i = 0;\r\n\r\n      // Subtract b from a.\r\n      for (; aL--;) {\r\n        a[aL] -= i;\r\n        i = a[aL] < b[aL] ? 1 : 0;\r\n        a[aL] = i * BASE + a[aL] - b[aL];\r\n      }\r\n\r\n      // Remove leading zeros.\r\n      for (; !a[0] && a.length > 1;) a.shift();\r\n    }\r\n\r\n    return function (x, y, pr, dp) {\r\n      var cmp, e, i, k, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz,\r\n        Ctor = x.constructor,\r\n        sign = x.s == y.s ? 1 : -1,\r\n        xd = x.d,\r\n        yd = y.d;\r\n\r\n      // Either 0?\r\n      if (!x.s) return new Ctor(x);\r\n      if (!y.s) throw Error(decimalError + 'Division by zero');\r\n\r\n      e = x.e - y.e;\r\n      yL = yd.length;\r\n      xL = xd.length;\r\n      q = new Ctor(sign);\r\n      qd = q.d = [];\r\n\r\n      // Result exponent may be one less than e.\r\n      for (i = 0; yd[i] == (xd[i] || 0); ) ++i;\r\n      if (yd[i] > (xd[i] || 0)) --e;\r\n\r\n      if (pr == null) {\r\n        sd = pr = Ctor.precision;\r\n      } else if (dp) {\r\n        sd = pr + (getBase10Exponent(x) - getBase10Exponent(y)) + 1;\r\n      } else {\r\n        sd = pr;\r\n      }\r\n\r\n      if (sd < 0) return new Ctor(0);\r\n\r\n      // Convert precision in number of base 10 digits to base 1e7 digits.\r\n      sd = sd / LOG_BASE + 2 | 0;\r\n      i = 0;\r\n\r\n      // divisor < 1e7\r\n      if (yL == 1) {\r\n        k = 0;\r\n        yd = yd[0];\r\n        sd++;\r\n\r\n        // k is the carry.\r\n        for (; (i < xL || k) && sd--; i++) {\r\n          t = k * BASE + (xd[i] || 0);\r\n          qd[i] = t / yd | 0;\r\n          k = t % yd | 0;\r\n        }\r\n\r\n      // divisor >= 1e7\r\n      } else {\r\n\r\n        // Normalise xd and yd so highest order digit of yd is >= BASE/2\r\n        k = BASE / (yd[0] + 1) | 0;\r\n\r\n        if (k > 1) {\r\n          yd = multiplyInteger(yd, k);\r\n          xd = multiplyInteger(xd, k);\r\n          yL = yd.length;\r\n          xL = xd.length;\r\n        }\r\n\r\n        xi = yL;\r\n        rem = xd.slice(0, yL);\r\n        remL = rem.length;\r\n\r\n        // Add zeros to make remainder as long as divisor.\r\n        for (; remL < yL;) rem[remL++] = 0;\r\n\r\n        yz = yd.slice();\r\n        yz.unshift(0);\r\n        yd0 = yd[0];\r\n\r\n        if (yd[1] >= BASE / 2) ++yd0;\r\n\r\n        do {\r\n          k = 0;\r\n\r\n          // Compare divisor and remainder.\r\n          cmp = compare(yd, rem, yL, remL);\r\n\r\n          // If divisor < remainder.\r\n          if (cmp < 0) {\r\n\r\n            // Calculate trial digit, k.\r\n            rem0 = rem[0];\r\n            if (yL != remL) rem0 = rem0 * BASE + (rem[1] || 0);\r\n\r\n            // k will be how many times the divisor goes into the current remainder.\r\n            k = rem0 / yd0 | 0;\r\n\r\n            //  Algorithm:\r\n            //  1. product = divisor * trial digit (k)\r\n            //  2. if product > remainder: product -= divisor, k--\r\n            //  3. remainder -= product\r\n            //  4. if product was < remainder at 2:\r\n            //    5. compare new remainder and divisor\r\n            //    6. If remainder > divisor: remainder -= divisor, k++\r\n\r\n            if (k > 1) {\r\n              if (k >= BASE) k = BASE - 1;\r\n\r\n              // product = divisor * trial digit.\r\n              prod = multiplyInteger(yd, k);\r\n              prodL = prod.length;\r\n              remL = rem.length;\r\n\r\n              // Compare product and remainder.\r\n              cmp = compare(prod, rem, prodL, remL);\r\n\r\n              // product > remainder.\r\n              if (cmp == 1) {\r\n                k--;\r\n\r\n                // Subtract divisor from product.\r\n                subtract(prod, yL < prodL ? yz : yd, prodL);\r\n              }\r\n            } else {\r\n\r\n              // cmp is -1.\r\n              // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1\r\n              // to avoid it. If k is 1 there is a need to compare yd and rem again below.\r\n              if (k == 0) cmp = k = 1;\r\n              prod = yd.slice();\r\n            }\r\n\r\n            prodL = prod.length;\r\n            if (prodL < remL) prod.unshift(0);\r\n\r\n            // Subtract product from remainder.\r\n            subtract(rem, prod, remL);\r\n\r\n            // If product was < previous remainder.\r\n            if (cmp == -1) {\r\n              remL = rem.length;\r\n\r\n              // Compare divisor and new remainder.\r\n              cmp = compare(yd, rem, yL, remL);\r\n\r\n              // If divisor < new remainder, subtract divisor from remainder.\r\n              if (cmp < 1) {\r\n                k++;\r\n\r\n                // Subtract divisor from remainder.\r\n                subtract(rem, yL < remL ? yz : yd, remL);\r\n              }\r\n            }\r\n\r\n            remL = rem.length;\r\n          } else if (cmp === 0) {\r\n            k++;\r\n            rem = [0];\r\n          }    // if cmp === 1, k will be 0\r\n\r\n          // Add the next digit, k, to the result array.\r\n          qd[i++] = k;\r\n\r\n          // Update the remainder.\r\n          if (cmp && rem[0]) {\r\n            rem[remL++] = xd[xi] || 0;\r\n          } else {\r\n            rem = [xd[xi]];\r\n            remL = 1;\r\n          }\r\n\r\n        } while ((xi++ < xL || rem[0] !== void 0) && sd--);\r\n      }\r\n\r\n      // Leading zero?\r\n      if (!qd[0]) qd.shift();\r\n\r\n      q.e = e;\r\n\r\n      return round(q, dp ? pr + getBase10Exponent(q) + 1 : pr);\r\n    };\r\n  })();\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of `x` truncated to `sd`\r\n   * significant digits.\r\n   *\r\n   * Taylor/Maclaurin series.\r\n   *\r\n   * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...\r\n   *\r\n   * Argument reduction:\r\n   *   Repeat x = x / 32, k += 5, until |x| < 0.1\r\n   *   exp(x) = exp(x / 2^k)^(2^k)\r\n   *\r\n   * Previously, the argument was initially reduced by\r\n   * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)\r\n   * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was\r\n   * found to be slower than just dividing repeatedly by 32 as above.\r\n   *\r\n   * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)\r\n   *\r\n   *  exp(x) is non-terminating for any finite, non-zero x.\r\n   *\r\n   */\r\n  function exp(x, sd) {\r\n    var denominator, guard, pow, sum, t, wpr,\r\n      i = 0,\r\n      k = 0,\r\n      Ctor = x.constructor,\r\n      pr = Ctor.precision;\r\n\r\n    if (getBase10Exponent(x) > 16) throw Error(exponentOutOfRange + getBase10Exponent(x));\r\n\r\n    // exp(0) = 1\r\n    if (!x.s) return new Ctor(ONE);\r\n\r\n    if (sd == null) {\r\n      external = false;\r\n      wpr = pr;\r\n    } else {\r\n      wpr = sd;\r\n    }\r\n\r\n    t = new Ctor(0.03125);\r\n\r\n    while (x.abs().gte(0.1)) {\r\n      x = x.times(t);    // x = x / 2^5\r\n      k += 5;\r\n    }\r\n\r\n    // Estimate the precision increase necessary to ensure the first 4 rounding digits are correct.\r\n    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;\r\n    wpr += guard;\r\n    denominator = pow = sum = new Ctor(ONE);\r\n    Ctor.precision = wpr;\r\n\r\n    for (;;) {\r\n      pow = round(pow.times(x), wpr);\r\n      denominator = denominator.times(++i);\r\n      t = sum.plus(divide(pow, denominator, wpr));\r\n\r\n      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\r\n        while (k--) sum = round(sum.times(sum), wpr);\r\n        Ctor.precision = pr;\r\n        return sd == null ? (external = true, round(sum, pr)) : sum;\r\n      }\r\n\r\n      sum = t;\r\n    }\r\n  }\r\n\r\n\r\n  // Calculate the base 10 exponent from the base 1e7 exponent.\r\n  function getBase10Exponent(x) {\r\n    var e = x.e * LOG_BASE,\r\n      w = x.d[0];\r\n\r\n    // Add the number of digits of the first word of the digits array.\r\n    for (; w >= 10; w /= 10) e++;\r\n    return e;\r\n  }\r\n\r\n\r\n  function getLn10(Ctor, sd, pr) {\r\n\r\n    if (sd > Ctor.LN10.sd()) {\r\n\r\n\r\n      // Reset global state in case the exception is caught.\r\n      external = true;\r\n      if (pr) Ctor.precision = pr;\r\n      throw Error(decimalError + 'LN10 precision limit exceeded');\r\n    }\r\n\r\n    return round(new Ctor(Ctor.LN10), sd);\r\n  }\r\n\r\n\r\n  function getZeroString(k) {\r\n    var zs = '';\r\n    for (; k--;) zs += '0';\r\n    return zs;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of `x` truncated to `sd` significant\r\n   * digits.\r\n   *\r\n   *  ln(n) is non-terminating (n != 1)\r\n   *\r\n   */\r\n  function ln(y, sd) {\r\n    var c, c0, denominator, e, numerator, sum, t, wpr, x2,\r\n      n = 1,\r\n      guard = 10,\r\n      x = y,\r\n      xd = x.d,\r\n      Ctor = x.constructor,\r\n      pr = Ctor.precision;\r\n\r\n    // ln(-x) = NaN\r\n    // ln(0) = -Infinity\r\n    if (x.s < 1) throw Error(decimalError + (x.s ? 'NaN' : '-Infinity'));\r\n\r\n    // ln(1) = 0\r\n    if (x.eq(ONE)) return new Ctor(0);\r\n\r\n    if (sd == null) {\r\n      external = false;\r\n      wpr = pr;\r\n    } else {\r\n      wpr = sd;\r\n    }\r\n\r\n    if (x.eq(10)) {\r\n      if (sd == null) external = true;\r\n      return getLn10(Ctor, wpr);\r\n    }\r\n\r\n    wpr += guard;\r\n    Ctor.precision = wpr;\r\n    c = digitsToString(xd);\r\n    c0 = c.charAt(0);\r\n    e = getBase10Exponent(x);\r\n\r\n    if (Math.abs(e) < 1.5e15) {\r\n\r\n      // Argument reduction.\r\n      // The series converges faster the closer the argument is to 1, so using\r\n      // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b\r\n      // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,\r\n      // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can\r\n      // later be divided by this number, then separate out the power of 10 using\r\n      // ln(a*10^b) = ln(a) + b*ln(10).\r\n\r\n      // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).\r\n      //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {\r\n      // max n is 6 (gives 0.7 - 1.3)\r\n      while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {\r\n        x = x.times(y);\r\n        c = digitsToString(x.d);\r\n        c0 = c.charAt(0);\r\n        n++;\r\n      }\r\n\r\n      e = getBase10Exponent(x);\r\n\r\n      if (c0 > 1) {\r\n        x = new Ctor('0.' + c);\r\n        e++;\r\n      } else {\r\n        x = new Ctor(c0 + '.' + c.slice(1));\r\n      }\r\n    } else {\r\n\r\n      // The argument reduction method above may result in overflow if the argument y is a massive\r\n      // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this\r\n      // function using ln(x*10^e) = ln(x) + e*ln(10).\r\n      t = getLn10(Ctor, wpr + 2, pr).times(e + '');\r\n      x = ln(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);\r\n\r\n      Ctor.precision = pr;\r\n      return sd == null ? (external = true, round(x, pr)) : x;\r\n    }\r\n\r\n    // x is reduced to a value near 1.\r\n\r\n    // Taylor series.\r\n    // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)\r\n    // where x = (y - 1)/(y + 1)    (|x| < 1)\r\n    sum = numerator = x = divide(x.minus(ONE), x.plus(ONE), wpr);\r\n    x2 = round(x.times(x), wpr);\r\n    denominator = 3;\r\n\r\n    for (;;) {\r\n      numerator = round(numerator.times(x2), wpr);\r\n      t = sum.plus(divide(numerator, new Ctor(denominator), wpr));\r\n\r\n      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\r\n        sum = sum.times(2);\r\n\r\n        // Reverse the argument reduction.\r\n        if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));\r\n        sum = divide(sum, new Ctor(n), wpr);\r\n\r\n        Ctor.precision = pr;\r\n        return sd == null ? (external = true, round(sum, pr)) : sum;\r\n      }\r\n\r\n      sum = t;\r\n      denominator += 2;\r\n    }\r\n  }\r\n\r\n\r\n  /*\r\n   * Parse the value of a new Decimal `x` from string `str`.\r\n   */\r\n  function parseDecimal(x, str) {\r\n    var e, i, len;\r\n\r\n    // Decimal point?\r\n    if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n    // Exponential form?\r\n    if ((i = str.search(/e/i)) > 0) {\r\n\r\n      // Determine exponent.\r\n      if (e < 0) e = i;\r\n      e += +str.slice(i + 1);\r\n      str = str.substring(0, i);\r\n    } else if (e < 0) {\r\n\r\n      // Integer.\r\n      e = str.length;\r\n    }\r\n\r\n    // Determine leading zeros.\r\n    for (i = 0; str.charCodeAt(i) === 48;) ++i;\r\n\r\n    // Determine trailing zeros.\r\n    for (len = str.length; str.charCodeAt(len - 1) === 48;) --len;\r\n    str = str.slice(i, len);\r\n\r\n    if (str) {\r\n      len -= i;\r\n      e = e - i - 1;\r\n      x.e = mathfloor(e / LOG_BASE);\r\n      x.d = [];\r\n\r\n      // Transform base\r\n\r\n      // e is the base 10 exponent.\r\n      // i is where to slice str to get the first word of the digits array.\r\n      i = (e + 1) % LOG_BASE;\r\n      if (e < 0) i += LOG_BASE;\r\n\r\n      if (i < len) {\r\n        if (i) x.d.push(+str.slice(0, i));\r\n        for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));\r\n        str = str.slice(i);\r\n        i = LOG_BASE - str.length;\r\n      } else {\r\n        i -= len;\r\n      }\r\n\r\n      for (; i--;) str += '0';\r\n      x.d.push(+str);\r\n\r\n      if (external && (x.e > MAX_E || x.e < -MAX_E)) throw Error(exponentOutOfRange + e);\r\n    } else {\r\n\r\n      // Zero.\r\n      x.s = 0;\r\n      x.e = 0;\r\n      x.d = [0];\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Round `x` to `sd` significant digits, using rounding mode `rm` if present (truncate otherwise).\r\n   */\r\n   function round(x, sd, rm) {\r\n    var i, j, k, n, rd, doRound, w, xdi,\r\n      xd = x.d;\r\n\r\n    // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n    // w: the word of xd which contains the rounding digit, a base 1e7 number.\r\n    // xdi: the index of w within xd.\r\n    // n: the number of digits of w.\r\n    // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if\r\n    // they had leading zeros)\r\n    // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).\r\n\r\n    // Get the length of the first word of the digits array xd.\r\n    for (n = 1, k = xd[0]; k >= 10; k /= 10) n++;\r\n    i = sd - n;\r\n\r\n    // Is the rounding digit in the first word of xd?\r\n    if (i < 0) {\r\n      i += LOG_BASE;\r\n      j = sd;\r\n      w = xd[xdi = 0];\r\n    } else {\r\n      xdi = Math.ceil((i + 1) / LOG_BASE);\r\n      k = xd.length;\r\n      if (xdi >= k) return x;\r\n      w = k = xd[xdi];\r\n\r\n      // Get the number of digits of w.\r\n      for (n = 1; k >= 10; k /= 10) n++;\r\n\r\n      // Get the index of rd within w.\r\n      i %= LOG_BASE;\r\n\r\n      // Get the index of rd within w, adjusted for leading zeros.\r\n      // The number of leading zeros of w is given by LOG_BASE - n.\r\n      j = i - LOG_BASE + n;\r\n    }\r\n\r\n    if (rm !== void 0) {\r\n      k = mathpow(10, n - j - 1);\r\n\r\n      // Get the rounding digit at index j of w.\r\n      rd = w / k % 10 | 0;\r\n\r\n      // Are there any non-zero digits after the rounding digit?\r\n      doRound = sd < 0 || xd[xdi + 1] !== void 0 || w % k;\r\n\r\n      // The expression `w % mathpow(10, n - j - 1)` returns all the digits of w to the right of the\r\n      // digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression will give\r\n      // 714.\r\n\r\n      doRound = rm < 4\r\n        ? (rd || doRound) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n        : rd > 5 || rd == 5 && (rm == 4 || doRound || rm == 6 &&\r\n\r\n          // Check whether the digit to the left of the rounding digit is odd.\r\n          ((i > 0 ? j > 0 ? w / mathpow(10, n - j) : 0 : xd[xdi - 1]) % 10) & 1 ||\r\n            rm == (x.s < 0 ? 8 : 7));\r\n    }\r\n\r\n    if (sd < 1 || !xd[0]) {\r\n      if (doRound) {\r\n        k = getBase10Exponent(x);\r\n        xd.length = 1;\r\n\r\n        // Convert sd to decimal places.\r\n        sd = sd - k - 1;\r\n\r\n        // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n        xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);\r\n        x.e = mathfloor(-sd / LOG_BASE) || 0;\r\n      } else {\r\n        xd.length = 1;\r\n\r\n        // Zero.\r\n        xd[0] = x.e = x.s = 0;\r\n      }\r\n\r\n      return x;\r\n    }\r\n\r\n    // Remove excess digits.\r\n    if (i == 0) {\r\n      xd.length = xdi;\r\n      k = 1;\r\n      xdi--;\r\n    } else {\r\n      xd.length = xdi + 1;\r\n      k = mathpow(10, LOG_BASE - i);\r\n\r\n      // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n      // j > 0 means i > number of leading zeros of w.\r\n      xd[xdi] = j > 0 ? (w / mathpow(10, n - j) % mathpow(10, j) | 0) * k : 0;\r\n    }\r\n\r\n    if (doRound) {\r\n      for (;;) {\r\n\r\n        // Is the digit to be rounded up in the first word of xd?\r\n        if (xdi == 0) {\r\n          if ((xd[0] += k) == BASE) {\r\n            xd[0] = 1;\r\n            ++x.e;\r\n          }\r\n\r\n          break;\r\n        } else {\r\n          xd[xdi] += k;\r\n          if (xd[xdi] != BASE) break;\r\n          xd[xdi--] = 0;\r\n          k = 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (i = xd.length; xd[--i] === 0;) xd.pop();\r\n\r\n    if (external && (x.e > MAX_E || x.e < -MAX_E)) {\r\n      throw Error(exponentOutOfRange + getBase10Exponent(x));\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  function subtract(x, y) {\r\n    var d, e, i, j, k, len, xd, xe, xLTy, yd,\r\n      Ctor = x.constructor,\r\n      pr = Ctor.precision;\r\n\r\n    // Return y negated if x is zero.\r\n    // Return x if y is zero and x is non-zero.\r\n    if (!x.s || !y.s) {\r\n      if (y.s) y.s = -y.s;\r\n      else y = new Ctor(x);\r\n      return external ? round(y, pr) : y;\r\n    }\r\n\r\n    xd = x.d;\r\n    yd = y.d;\r\n\r\n    // x and y are non-zero numbers with the same sign.\r\n\r\n    e = y.e;\r\n    xe = x.e;\r\n    xd = xd.slice();\r\n    k = xe - e;\r\n\r\n    // If exponents differ...\r\n    if (k) {\r\n      xLTy = k < 0;\r\n\r\n      if (xLTy) {\r\n        d = xd;\r\n        k = -k;\r\n        len = yd.length;\r\n      } else {\r\n        d = yd;\r\n        e = xe;\r\n        len = xd.length;\r\n      }\r\n\r\n      // Numbers with massively different exponents would result in a very high number of zeros\r\n      // needing to be prepended, but this can be avoided while still ensuring correct rounding by\r\n      // limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.\r\n      i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;\r\n\r\n      if (k > i) {\r\n        k = i;\r\n        d.length = 1;\r\n      }\r\n\r\n      // Prepend zeros to equalise exponents.\r\n      d.reverse();\r\n      for (i = k; i--;) d.push(0);\r\n      d.reverse();\r\n\r\n    // Base 1e7 exponents equal.\r\n    } else {\r\n\r\n      // Check digits to determine which is the bigger number.\r\n\r\n      i = xd.length;\r\n      len = yd.length;\r\n      xLTy = i < len;\r\n      if (xLTy) len = i;\r\n\r\n      for (i = 0; i < len; i++) {\r\n        if (xd[i] != yd[i]) {\r\n          xLTy = xd[i] < yd[i];\r\n          break;\r\n        }\r\n      }\r\n\r\n      k = 0;\r\n    }\r\n\r\n    if (xLTy) {\r\n      d = xd;\r\n      xd = yd;\r\n      yd = d;\r\n      y.s = -y.s;\r\n    }\r\n\r\n    len = xd.length;\r\n\r\n    // Append zeros to xd if shorter.\r\n    // Don't add zeros to yd if shorter as subtraction only needs to start at yd length.\r\n    for (i = yd.length - len; i > 0; --i) xd[len++] = 0;\r\n\r\n    // Subtract yd from xd.\r\n    for (i = yd.length; i > k;) {\r\n      if (xd[--i] < yd[i]) {\r\n        for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;\r\n        --xd[j];\r\n        xd[i] += BASE;\r\n      }\r\n\r\n      xd[i] -= yd[i];\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (; xd[--len] === 0;) xd.pop();\r\n\r\n    // Remove leading zeros and adjust exponent accordingly.\r\n    for (; xd[0] === 0; xd.shift()) --e;\r\n\r\n    // Zero?\r\n    if (!xd[0]) return new Ctor(0);\r\n\r\n    y.d = xd;\r\n    y.e = e;\r\n\r\n    //return external && xd.length >= pr / LOG_BASE ? round(y, pr) : y;\r\n    return external ? round(y, pr) : y;\r\n  }\r\n\r\n\r\n  function toString(x, isExp, sd) {\r\n    var k,\r\n      e = getBase10Exponent(x),\r\n      str = digitsToString(x.d),\r\n      len = str.length;\r\n\r\n    if (isExp) {\r\n      if (sd && (k = sd - len) > 0) {\r\n        str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);\r\n      } else if (len > 1) {\r\n        str = str.charAt(0) + '.' + str.slice(1);\r\n      }\r\n\r\n      str = str + (e < 0 ? 'e' : 'e+') + e;\r\n    } else if (e < 0) {\r\n      str = '0.' + getZeroString(-e - 1) + str;\r\n      if (sd && (k = sd - len) > 0) str += getZeroString(k);\r\n    } else if (e >= len) {\r\n      str += getZeroString(e + 1 - len);\r\n      if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);\r\n    } else {\r\n      if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);\r\n      if (sd && (k = sd - len) > 0) {\r\n        if (e + 1 === len) str += '.';\r\n        str += getZeroString(k);\r\n      }\r\n    }\r\n\r\n    return x.s < 0 ? '-' + str : str;\r\n  }\r\n\r\n\r\n  // Does not strip trailing zeros.\r\n  function truncate(arr, len) {\r\n    if (arr.length > len) {\r\n      arr.length = len;\r\n      return true;\r\n    }\r\n  }\r\n\r\n\r\n  // Decimal methods\r\n\r\n\r\n  /*\r\n   *  clone\r\n   *  config/set\r\n   */\r\n\r\n\r\n  /*\r\n   * Create and return a Decimal constructor with the same configuration properties as this Decimal\r\n   * constructor.\r\n   *\r\n   */\r\n  function clone(obj) {\r\n    var i, p, ps;\r\n\r\n    /*\r\n     * The Decimal constructor and exported function.\r\n     * Return a new Decimal instance.\r\n     *\r\n     * value {number|string|Decimal} A numeric value.\r\n     *\r\n     */\r\n    function Decimal(value) {\r\n      var x = this;\r\n\r\n      // Decimal called without new.\r\n      if (!(x instanceof Decimal)) return new Decimal(value);\r\n\r\n      // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor\r\n      // which points to Object.\r\n      x.constructor = Decimal;\r\n\r\n      // Duplicate.\r\n      if (value instanceof Decimal) {\r\n        x.s = value.s;\r\n        x.e = value.e;\r\n        x.d = (value = value.d) ? value.slice() : value;\r\n        return;\r\n      }\r\n\r\n      if (typeof value === 'number') {\r\n\r\n        // Reject Infinity/NaN.\r\n        if (value * 0 !== 0) {\r\n          throw Error(invalidArgument + value);\r\n        }\r\n\r\n        if (value > 0) {\r\n          x.s = 1;\r\n        } else if (value < 0) {\r\n          value = -value;\r\n          x.s = -1;\r\n        } else {\r\n          x.s = 0;\r\n          x.e = 0;\r\n          x.d = [0];\r\n          return;\r\n        }\r\n\r\n        // Fast path for small integers.\r\n        if (value === ~~value && value < 1e7) {\r\n          x.e = 0;\r\n          x.d = [value];\r\n          return;\r\n        }\r\n\r\n        return parseDecimal(x, value.toString());\r\n      } else if (typeof value !== 'string') {\r\n        throw Error(invalidArgument + value);\r\n      }\r\n\r\n      // Minus sign?\r\n      if (value.charCodeAt(0) === 45) {\r\n        value = value.slice(1);\r\n        x.s = -1;\r\n      } else {\r\n        x.s = 1;\r\n      }\r\n\r\n      if (isDecimal.test(value)) parseDecimal(x, value);\r\n      else throw Error(invalidArgument + value);\r\n    }\r\n\r\n    Decimal.prototype = P;\r\n\r\n    Decimal.ROUND_UP = 0;\r\n    Decimal.ROUND_DOWN = 1;\r\n    Decimal.ROUND_CEIL = 2;\r\n    Decimal.ROUND_FLOOR = 3;\r\n    Decimal.ROUND_HALF_UP = 4;\r\n    Decimal.ROUND_HALF_DOWN = 5;\r\n    Decimal.ROUND_HALF_EVEN = 6;\r\n    Decimal.ROUND_HALF_CEIL = 7;\r\n    Decimal.ROUND_HALF_FLOOR = 8;\r\n\r\n    Decimal.clone = clone;\r\n    Decimal.config = Decimal.set = config;\r\n\r\n    if (obj === void 0) obj = {};\r\n    if (obj) {\r\n      ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'LN10'];\r\n      for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];\r\n    }\r\n\r\n    Decimal.config(obj);\r\n\r\n    return Decimal;\r\n  }\r\n\r\n\r\n  /*\r\n   * Configure global settings for a Decimal constructor.\r\n   *\r\n   * `obj` is an object with one or more of the following properties,\r\n   *\r\n   *   precision  {number}\r\n   *   rounding   {number}\r\n   *   toExpNeg   {number}\r\n   *   toExpPos   {number}\r\n   *\r\n   * E.g. Decimal.config({ precision: 20, rounding: 4 })\r\n   *\r\n   */\r\n  function config(obj) {\r\n    if (!obj || typeof obj !== 'object') {\r\n      throw Error(decimalError + 'Object expected');\r\n    }\r\n    var i, p, v,\r\n      ps = [\r\n        'precision', 1, MAX_DIGITS,\r\n        'rounding', 0, 8,\r\n        'toExpNeg', -1 / 0, 0,\r\n        'toExpPos', 0, 1 / 0\r\n      ];\r\n\r\n    for (i = 0; i < ps.length; i += 3) {\r\n      if ((v = obj[p = ps[i]]) !== void 0) {\r\n        if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;\r\n        else throw Error(invalidArgument + p + ': ' + v);\r\n      }\r\n    }\r\n\r\n    if ((v = obj[p = 'LN10']) !== void 0) {\r\n        if (v == Math.LN10) this[p] = new this(v);\r\n        else throw Error(invalidArgument + p + ': ' + v);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n\r\n  // Create and configure initial Decimal constructor.\r\n  Decimal = clone(Decimal);\r\n\r\n  Decimal['default'] = Decimal.Decimal = Decimal;\r\n\r\n  // Internal constant.\r\n  ONE = new Decimal(1);\r\n\r\n\r\n  // Export.\r\n\r\n\r\n  // AMD.\r\n  if (typeof define == 'function' && define.amd) {\r\n    define(function () {\r\n      return Decimal;\r\n    });\r\n\r\n  // Node and other environments that support module.exports.\r\n  } else if (typeof module != 'undefined' && module.exports) {\r\n    module.exports = Decimal;\r\n\r\n    // Browser.\r\n  } else {\r\n    if (!globalScope) {\r\n      globalScope = typeof self != 'undefined' && self && self.self == self\r\n        ? self : Function('return this')();\r\n    }\r\n\r\n    globalScope.Decimal = Decimal;\r\n  }\r\n})(this);\r\n"]},"metadata":{},"sourceType":"script"}