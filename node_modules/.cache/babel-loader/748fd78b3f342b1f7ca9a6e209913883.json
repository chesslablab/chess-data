{"ast":null,"code":"/*\n * Module dependencies\n */\nvar balanced = require(\"balanced-match\");\n/**\n * Expose `reduceFunctionCall`\n *\n * @type {Function}\n */\n\n\nmodule.exports = reduceFunctionCall;\n/**\n * Walkthrough all expressions, evaluate them and insert them into the declaration\n *\n * @param {Array} expressions\n * @param {Object} declaration\n */\n\nfunction reduceFunctionCall(string, functionRE, callback) {\n  var call = string;\n  return getFunctionCalls(string, functionRE).reduce(function (string, obj) {\n    return string.replace(obj.functionIdentifier + \"(\" + obj.matches.body + \")\", evalFunctionCall(obj.matches.body, obj.functionIdentifier, callback, call, functionRE));\n  }, string);\n}\n/**\n * Parses expressions in a value\n *\n * @param {String} value\n * @returns {Array}\n * @api private\n */\n\n\nfunction getFunctionCalls(call, functionRE) {\n  var expressions = [];\n  var fnRE = typeof functionRE === \"string\" ? new RegExp(\"\\\\b(\" + functionRE + \")\\\\(\") : functionRE;\n\n  do {\n    var searchMatch = fnRE.exec(call);\n\n    if (!searchMatch) {\n      return expressions;\n    }\n\n    if (searchMatch[1] === undefined) {\n      throw new Error(\"Missing the first couple of parenthesis to get the function identifier in \" + functionRE);\n    }\n\n    var fn = searchMatch[1];\n    var startIndex = searchMatch.index;\n    var matches = balanced(\"(\", \")\", call.substring(startIndex));\n\n    if (!matches || matches.start !== searchMatch[0].length - 1) {\n      throw new SyntaxError(fn + \"(): missing closing ')' in the value '\" + call + \"'\");\n    }\n\n    expressions.push({\n      matches: matches,\n      functionIdentifier: fn\n    });\n    call = matches.post;\n  } while (fnRE.test(call));\n\n  return expressions;\n}\n/**\n * Evaluates an expression\n *\n * @param {String} expression\n * @returns {String}\n * @api private\n */\n\n\nfunction evalFunctionCall(string, functionIdentifier, callback, call, functionRE) {\n  // allow recursivity\n  return callback(reduceFunctionCall(string, functionRE, callback), functionIdentifier, call);\n}","map":{"version":3,"sources":["/usr/share/pgn-chess/node_modules/reduce-function-call/index.js"],"names":["balanced","require","module","exports","reduceFunctionCall","string","functionRE","callback","call","getFunctionCalls","reduce","obj","replace","functionIdentifier","matches","body","evalFunctionCall","expressions","fnRE","RegExp","searchMatch","exec","undefined","Error","fn","startIndex","index","substring","start","length","SyntaxError","push","post","test"],"mappings":"AAAA;;;AAGA,IAAIA,QAAQ,GAAGC,OAAO,CAAC,gBAAD,CAAtB;AAEA;;;;;;;AAKAC,MAAM,CAACC,OAAP,GAAiBC,kBAAjB;AAEA;;;;;;;AAOA,SAASA,kBAAT,CAA4BC,MAA5B,EAAoCC,UAApC,EAAgDC,QAAhD,EAA0D;AACxD,MAAIC,IAAI,GAAGH,MAAX;AACA,SAAOI,gBAAgB,CAACJ,MAAD,EAASC,UAAT,CAAhB,CAAqCI,MAArC,CAA4C,UAASL,MAAT,EAAiBM,GAAjB,EAAsB;AACvE,WAAON,MAAM,CAACO,OAAP,CAAeD,GAAG,CAACE,kBAAJ,GAAyB,GAAzB,GAA+BF,GAAG,CAACG,OAAJ,CAAYC,IAA3C,GAAkD,GAAjE,EAAsEC,gBAAgB,CAACL,GAAG,CAACG,OAAJ,CAAYC,IAAb,EAAmBJ,GAAG,CAACE,kBAAvB,EAA2CN,QAA3C,EAAqDC,IAArD,EAA2DF,UAA3D,CAAtF,CAAP;AACD,GAFM,EAEJD,MAFI,CAAP;AAGD;AAED;;;;;;;;;AAQA,SAASI,gBAAT,CAA0BD,IAA1B,EAAgCF,UAAhC,EAA4C;AAC1C,MAAIW,WAAW,GAAG,EAAlB;AAEA,MAAIC,IAAI,GAAG,OAAOZ,UAAP,KAAsB,QAAtB,GAAiC,IAAIa,MAAJ,CAAW,SAASb,UAAT,GAAsB,MAAjC,CAAjC,GAA4EA,UAAvF;;AACA,KAAG;AACD,QAAIc,WAAW,GAAGF,IAAI,CAACG,IAAL,CAAUb,IAAV,CAAlB;;AACA,QAAI,CAACY,WAAL,EAAkB;AAChB,aAAOH,WAAP;AACD;;AACD,QAAIG,WAAW,CAAC,CAAD,CAAX,KAAmBE,SAAvB,EAAkC;AAChC,YAAM,IAAIC,KAAJ,CAAU,+EAA+EjB,UAAzF,CAAN;AACD;;AACD,QAAIkB,EAAE,GAAGJ,WAAW,CAAC,CAAD,CAApB;AACA,QAAIK,UAAU,GAAGL,WAAW,CAACM,KAA7B;AACA,QAAIZ,OAAO,GAAGd,QAAQ,CAAC,GAAD,EAAM,GAAN,EAAWQ,IAAI,CAACmB,SAAL,CAAeF,UAAf,CAAX,CAAtB;;AAEA,QAAI,CAACX,OAAD,IAAYA,OAAO,CAACc,KAAR,KAAkBR,WAAW,CAAC,CAAD,CAAX,CAAeS,MAAf,GAAwB,CAA1D,EAA6D;AAC3D,YAAM,IAAIC,WAAJ,CAAgBN,EAAE,GAAG,wCAAL,GAAgDhB,IAAhD,GAAuD,GAAvE,CAAN;AACD;;AAEDS,IAAAA,WAAW,CAACc,IAAZ,CAAiB;AAACjB,MAAAA,OAAO,EAAEA,OAAV;AAAmBD,MAAAA,kBAAkB,EAAEW;AAAvC,KAAjB;AACAhB,IAAAA,IAAI,GAAGM,OAAO,CAACkB,IAAf;AACD,GAlBD,QAmBOd,IAAI,CAACe,IAAL,CAAUzB,IAAV,CAnBP;;AAqBA,SAAOS,WAAP;AACD;AAED;;;;;;;;;AAQA,SAASD,gBAAT,CAA2BX,MAA3B,EAAmCQ,kBAAnC,EAAuDN,QAAvD,EAAiEC,IAAjE,EAAuEF,UAAvE,EAAmF;AACjF;AACA,SAAOC,QAAQ,CAACH,kBAAkB,CAACC,MAAD,EAASC,UAAT,EAAqBC,QAArB,CAAnB,EAAmDM,kBAAnD,EAAuEL,IAAvE,CAAf;AACD","sourcesContent":["/*\n * Module dependencies\n */\nvar balanced = require(\"balanced-match\")\n\n/**\n * Expose `reduceFunctionCall`\n *\n * @type {Function}\n */\nmodule.exports = reduceFunctionCall\n\n/**\n * Walkthrough all expressions, evaluate them and insert them into the declaration\n *\n * @param {Array} expressions\n * @param {Object} declaration\n */\n\nfunction reduceFunctionCall(string, functionRE, callback) {\n  var call = string\n  return getFunctionCalls(string, functionRE).reduce(function(string, obj) {\n    return string.replace(obj.functionIdentifier + \"(\" + obj.matches.body + \")\", evalFunctionCall(obj.matches.body, obj.functionIdentifier, callback, call, functionRE))\n  }, string)\n}\n\n/**\n * Parses expressions in a value\n *\n * @param {String} value\n * @returns {Array}\n * @api private\n */\n\nfunction getFunctionCalls(call, functionRE) {\n  var expressions = []\n\n  var fnRE = typeof functionRE === \"string\" ? new RegExp(\"\\\\b(\" + functionRE + \")\\\\(\") : functionRE\n  do {\n    var searchMatch = fnRE.exec(call)\n    if (!searchMatch) {\n      return expressions\n    }\n    if (searchMatch[1] === undefined) {\n      throw new Error(\"Missing the first couple of parenthesis to get the function identifier in \" + functionRE)\n    }\n    var fn = searchMatch[1]\n    var startIndex = searchMatch.index\n    var matches = balanced(\"(\", \")\", call.substring(startIndex))\n\n    if (!matches || matches.start !== searchMatch[0].length - 1) {\n      throw new SyntaxError(fn + \"(): missing closing ')' in the value '\" + call + \"'\")\n    }\n\n    expressions.push({matches: matches, functionIdentifier: fn})\n    call = matches.post\n  }\n  while (fnRE.test(call))\n\n  return expressions\n}\n\n/**\n * Evaluates an expression\n *\n * @param {String} expression\n * @returns {String}\n * @api private\n */\n\nfunction evalFunctionCall (string, functionIdentifier, callback, call, functionRE) {\n  // allow recursivity\n  return callback(reduceFunctionCall(string, functionRE, callback), functionIdentifier, call)\n}\n"]},"metadata":{},"sourceType":"script"}