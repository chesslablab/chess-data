{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTickValuesFixedDomain = exports.getTickValues = exports.getNiceTickValues = void 0;\n\nvar _decimal = _interopRequireDefault(require(\"decimal.js-light\"));\n\nvar _utils = require(\"./util/utils\");\n\nvar _arithmetic = _interopRequireDefault(require(\"./util/arithmetic\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n/**\n * Calculate a interval of a minimum value and a maximum value\n *\n * @param  {Number} min       The minimum value\n * @param  {Number} max       The maximum value\n * @return {Array} An interval\n */\n\n\nfunction getValidInterval(_ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n      min = _ref2[0],\n      max = _ref2[1];\n\n  var validMin = min,\n      validMax = max; // exchange\n\n  if (min > max) {\n    validMin = max;\n    validMax = min;\n  }\n\n  return [validMin, validMax];\n}\n/**\n * Calculate the step which is easy to understand between ticks, like 10, 20, 25\n *\n * @param  {Decimal} roughStep        The rough step calculated by deviding the\n * difference by the tickCount\n * @param  {Boolean} allowDecimals    Allow the ticks to be decimals or not\n * @param  {Integer} correctionFactor A correction factor\n * @return {Decimal} The step which is easy to understand between two ticks\n */\n\n\nfunction getFormatStep(roughStep, allowDecimals, correctionFactor) {\n  if (roughStep.lte(0)) {\n    return new _decimal.default(0);\n  }\n\n  var digitCount = _arithmetic.default.getDigitCount(roughStep.toNumber()); // The ratio between the rough step and the smallest number which has a bigger\n  // order of magnitudes than the rough step\n\n\n  var digitCountValue = new _decimal.default(10).pow(digitCount);\n  var stepRatio = roughStep.div(digitCountValue); // When an integer and a float multiplied, the accuracy of result may be wrong\n\n  var stepRatioScale = digitCount !== 1 ? 0.05 : 0.1;\n  var amendStepRatio = new _decimal.default(Math.ceil(stepRatio.div(stepRatioScale).toNumber())).add(correctionFactor).mul(stepRatioScale);\n  var formatStep = amendStepRatio.mul(digitCountValue);\n  return allowDecimals ? formatStep : new _decimal.default(Math.ceil(formatStep));\n}\n/**\n * calculate the ticks when the minimum value equals to the maximum value\n *\n * @param  {Number}  value         The minimum valuue which is also the maximum value\n * @param  {Integer} tickCount     The count of ticks\n * @param  {Boolean} allowDecimals Allow the ticks to be decimals or not\n * @return {Array}                 ticks\n */\n\n\nfunction getTickOfSingleValue(value, tickCount, allowDecimals) {\n  var step = 1; // calculate the middle value of ticks\n\n  var middle = new _decimal.default(value);\n\n  if (!middle.isint() && allowDecimals) {\n    var absVal = Math.abs(value);\n\n    if (absVal < 1) {\n      // The step should be a float number when the difference is smaller than 1\n      step = new _decimal.default(10).pow(_arithmetic.default.getDigitCount(value) - 1);\n      middle = new _decimal.default(Math.floor(middle.div(step).toNumber())).mul(step);\n    } else if (absVal > 1) {\n      // Return the maximum integer which is smaller than 'value' when 'value' is greater than 1\n      middle = new _decimal.default(Math.floor(value));\n    }\n  } else if (value === 0) {\n    middle = new _decimal.default(Math.floor((tickCount - 1) / 2));\n  } else if (!allowDecimals) {\n    middle = new _decimal.default(Math.floor(value));\n  }\n\n  var middleIndex = Math.floor((tickCount - 1) / 2);\n  var fn = (0, _utils.compose)((0, _utils.map)(function (n) {\n    return middle.add(new _decimal.default(n - middleIndex).mul(step)).toNumber();\n  }), _utils.range);\n  return fn(0, tickCount);\n}\n/**\n * Calculate the step\n *\n * @param  {Number}  min              The minimum value of an interval\n * @param  {Number}  max              The maximum value of an interval\n * @param  {Integer} tickCount        The count of ticks\n * @param  {Boolean} allowDecimals    Allow the ticks to be decimals or not\n * @param  {Number}  correctionFactor A correction factor\n * @return {Object}  The step, minimum value of ticks, maximum value of ticks\n */\n\n\nfunction calculateStep(min, max, tickCount, allowDecimals) {\n  var correctionFactor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0; // dirty hack (for recharts' test)\n\n  if (!Number.isFinite((max - min) / (tickCount - 1))) {\n    return {\n      step: new _decimal.default(0),\n      tickMin: new _decimal.default(0),\n      tickMax: new _decimal.default(0)\n    };\n  } // The step which is easy to understand between two ticks\n\n\n  var step = getFormatStep(new _decimal.default(max).sub(min).div(tickCount - 1), allowDecimals, correctionFactor); // A medial value of ticks\n\n  var middle; // When 0 is inside the interval, 0 should be a tick\n\n  if (min <= 0 && max >= 0) {\n    middle = new _decimal.default(0);\n  } else {\n    // calculate the middle value\n    middle = new _decimal.default(min).add(max).div(2); // minus modulo value\n\n    middle = middle.sub(new _decimal.default(middle).mod(step));\n  }\n\n  var belowCount = Math.ceil(middle.sub(min).div(step).toNumber());\n  var upCount = Math.ceil(new _decimal.default(max).sub(middle).div(step).toNumber());\n  var scaleCount = belowCount + upCount + 1;\n\n  if (scaleCount > tickCount) {\n    // When more ticks need to cover the interval, step should be bigger.\n    return calculateStep(min, max, tickCount, allowDecimals, correctionFactor + 1);\n  }\n\n  if (scaleCount < tickCount) {\n    // When less ticks can cover the interval, we should add some additional ticks\n    upCount = max > 0 ? upCount + (tickCount - scaleCount) : upCount;\n    belowCount = max > 0 ? belowCount : belowCount + (tickCount - scaleCount);\n  }\n\n  return {\n    step: step,\n    tickMin: middle.sub(new _decimal.default(belowCount).mul(step)),\n    tickMax: middle.add(new _decimal.default(upCount).mul(step))\n  };\n}\n/**\n * Calculate the ticks of an interval, the count of ticks will be guraranteed\n *\n * @param  {Number}  min, max      min: The minimum value, max: The maximum value\n * @param  {Integer} tickCount     The count of ticks\n * @param  {Boolean} allowDecimals Allow the ticks to be decimals or not\n * @return {Array}   ticks\n */\n\n\nfunction getNiceTickValuesFn(_ref3) {\n  var _ref4 = _slicedToArray(_ref3, 2),\n      min = _ref4[0],\n      max = _ref4[1];\n\n  var tickCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true; // More than two ticks should be return\n\n  var count = Math.max(tickCount, 2);\n\n  var _getValidInterval = getValidInterval([min, max]),\n      _getValidInterval2 = _slicedToArray(_getValidInterval, 2),\n      cormin = _getValidInterval2[0],\n      cormax = _getValidInterval2[1];\n\n  if (cormin === -Infinity || cormax === Infinity) {\n    var _values = cormax === Infinity ? [cormin].concat(_toConsumableArray((0, _utils.range)(0, tickCount - 1).map(function () {\n      return Infinity;\n    }))) : _toConsumableArray((0, _utils.range)(0, tickCount - 1).map(function () {\n      return -Infinity;\n    })).concat([cormax]);\n\n    return min > max ? (0, _utils.reverse)(_values) : _values;\n  }\n\n  if (cormin === cormax) {\n    return getTickOfSingleValue(cormin, tickCount, allowDecimals);\n  } // Get the step between two ticks\n\n\n  var _calculateStep = calculateStep(cormin, cormax, count, allowDecimals),\n      step = _calculateStep.step,\n      tickMin = _calculateStep.tickMin,\n      tickMax = _calculateStep.tickMax;\n\n  var values = _arithmetic.default.rangeStep(tickMin, tickMax.add(new _decimal.default(0.1).mul(step)), step);\n\n  return min > max ? (0, _utils.reverse)(values) : values;\n}\n/**\n * Calculate the ticks of an interval, the count of ticks won't be guraranteed\n *\n * @param  {Number}  min, max      min: The minimum value, max: The maximum value\n * @param  {Integer} tickCount     The count of ticks\n * @param  {Boolean} allowDecimals Allow the ticks to be decimals or not\n * @return {Array}   ticks\n */\n\n\nfunction getTickValuesFn(_ref5) {\n  var _ref6 = _slicedToArray(_ref5, 2),\n      min = _ref6[0],\n      max = _ref6[1];\n\n  var tickCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true; // More than two ticks should be return\n\n  var count = Math.max(tickCount, 2);\n\n  var _getValidInterval3 = getValidInterval([min, max]),\n      _getValidInterval4 = _slicedToArray(_getValidInterval3, 2),\n      cormin = _getValidInterval4[0],\n      cormax = _getValidInterval4[1];\n\n  if (cormin === -Infinity || cormax === Infinity) {\n    return [min, max];\n  }\n\n  if (cormin === cormax) {\n    return getTickOfSingleValue(cormin, tickCount, allowDecimals);\n  }\n\n  var step = getFormatStep(new _decimal.default(cormax).sub(cormin).div(count - 1), allowDecimals, 0);\n  var fn = (0, _utils.compose)((0, _utils.map)(function (n) {\n    return new _decimal.default(cormin).add(new _decimal.default(n).mul(step)).toNumber();\n  }), _utils.range);\n  var values = fn(0, count).filter(function (entry) {\n    return entry >= cormin && entry <= cormax;\n  });\n  return min > max ? (0, _utils.reverse)(values) : values;\n}\n/**\n * Calculate the ticks of an interval, the count of ticks won't be guraranteed,\n * but the domain will be guaranteed\n *\n * @param  {Number}  min, max      min: The minimum value, max: The maximum value\n * @param  {Integer} tickCount     The count of ticks\n * @param  {Boolean} allowDecimals Allow the ticks to be decimals or not\n * @return {Array}   ticks\n */\n\n\nfunction getTickValuesFixedDomainFn(_ref7, tickCount) {\n  var _ref8 = _slicedToArray(_ref7, 2),\n      min = _ref8[0],\n      max = _ref8[1];\n\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true; // More than two ticks should be return\n\n  var _getValidInterval5 = getValidInterval([min, max]),\n      _getValidInterval6 = _slicedToArray(_getValidInterval5, 2),\n      cormin = _getValidInterval6[0],\n      cormax = _getValidInterval6[1];\n\n  if (cormin === -Infinity || cormax === Infinity) {\n    return [min, max];\n  }\n\n  if (cormin === cormax) {\n    return [cormin];\n  }\n\n  var count = Math.max(tickCount, 2);\n  var step = getFormatStep(new _decimal.default(cormax).sub(cormin).div(count - 1), allowDecimals, 0);\n\n  var values = _toConsumableArray(_arithmetic.default.rangeStep(new _decimal.default(cormin), new _decimal.default(cormax).sub(new _decimal.default(0.99).mul(step)), step)).concat([cormax]);\n\n  return min > max ? (0, _utils.reverse)(values) : values;\n}\n\nvar getNiceTickValues = (0, _utils.memoize)(getNiceTickValuesFn);\nexports.getNiceTickValues = getNiceTickValues;\nvar getTickValues = (0, _utils.memoize)(getTickValuesFn);\nexports.getTickValues = getTickValues;\nvar getTickValuesFixedDomain = (0, _utils.memoize)(getTickValuesFixedDomainFn);\nexports.getTickValuesFixedDomain = getTickValuesFixedDomain;","map":{"version":3,"sources":["/usr/share/pgn-chess/node_modules/recharts-scale/lib/getNiceTickValues.js"],"names":["Object","defineProperty","exports","value","getTickValuesFixedDomain","getTickValues","getNiceTickValues","_decimal","_interopRequireDefault","require","_utils","_arithmetic","obj","__esModule","default","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","prototype","toString","call","Array","from","isArray","i","arr2","length","_slicedToArray","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","_arr","_n","_d","_e","undefined","_i","_s","next","done","push","err","getValidInterval","_ref","_ref2","min","max","validMin","validMax","getFormatStep","roughStep","allowDecimals","correctionFactor","lte","digitCount","getDigitCount","toNumber","digitCountValue","pow","stepRatio","div","stepRatioScale","amendStepRatio","Math","ceil","add","mul","formatStep","getTickOfSingleValue","tickCount","step","middle","isint","absVal","abs","floor","middleIndex","fn","compose","map","n","range","calculateStep","arguments","Number","isFinite","tickMin","tickMax","sub","mod","belowCount","upCount","scaleCount","getNiceTickValuesFn","_ref3","_ref4","count","_getValidInterval","_getValidInterval2","cormin","cormax","Infinity","_values","concat","reverse","_calculateStep","values","rangeStep","getTickValuesFn","_ref5","_ref6","_getValidInterval3","_getValidInterval4","filter","entry","getTickValuesFixedDomainFn","_ref7","_ref8","_getValidInterval5","_getValidInterval6","memoize"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,wBAAR,GAAmCF,OAAO,CAACG,aAAR,GAAwBH,OAAO,CAACI,iBAAR,GAA4B,KAAK,CAA5F;;AAEA,IAAIC,QAAQ,GAAGC,sBAAsB,CAACC,OAAO,CAAC,kBAAD,CAAR,CAArC;;AAEA,IAAIC,MAAM,GAAGD,OAAO,CAAC,cAAD,CAApB;;AAEA,IAAIE,WAAW,GAAGH,sBAAsB,CAACC,OAAO,CAAC,mBAAD,CAAR,CAAxC;;AAEA,SAASD,sBAAT,CAAgCI,GAAhC,EAAqC;AAAE,SAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;AAAEE,IAAAA,OAAO,EAAEF;AAAX,GAArC;AAAwD;;AAE/F,SAASG,kBAAT,CAA4BC,GAA5B,EAAiC;AAAE,SAAOC,kBAAkB,CAACD,GAAD,CAAlB,IAA2BE,gBAAgB,CAACF,GAAD,CAA3C,IAAoDG,kBAAkB,EAA7E;AAAkF;;AAErH,SAASA,kBAAT,GAA8B;AAAE,QAAM,IAAIC,SAAJ,CAAc,iDAAd,CAAN;AAAyE;;AAEzG,SAASF,gBAAT,CAA0BG,IAA1B,EAAgC;AAAE,MAAIC,MAAM,CAACC,QAAP,IAAmBvB,MAAM,CAACqB,IAAD,CAAzB,IAAmCrB,MAAM,CAACwB,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BL,IAA/B,MAAyC,oBAAhF,EAAsG,OAAOM,KAAK,CAACC,IAAN,CAAWP,IAAX,CAAP;AAA0B;;AAElK,SAASJ,kBAAT,CAA4BD,GAA5B,EAAiC;AAAE,MAAIW,KAAK,CAACE,OAAN,CAAcb,GAAd,CAAJ,EAAwB;AAAE,SAAK,IAAIc,CAAC,GAAG,CAAR,EAAWC,IAAI,GAAG,IAAIJ,KAAJ,CAAUX,GAAG,CAACgB,MAAd,CAAvB,EAA8CF,CAAC,GAAGd,GAAG,CAACgB,MAAtD,EAA8DF,CAAC,EAA/D,EAAmE;AAAEC,MAAAA,IAAI,CAACD,CAAD,CAAJ,GAAUd,GAAG,CAACc,CAAD,CAAb;AAAmB;;AAAC,WAAOC,IAAP;AAAc;AAAE;;AAEtK,SAASE,cAAT,CAAwBjB,GAAxB,EAA6Bc,CAA7B,EAAgC;AAAE,SAAOI,eAAe,CAAClB,GAAD,CAAf,IAAwBmB,qBAAqB,CAACnB,GAAD,EAAMc,CAAN,CAA7C,IAAyDM,gBAAgB,EAAhF;AAAqF;;AAEvH,SAASA,gBAAT,GAA4B;AAAE,QAAM,IAAIhB,SAAJ,CAAc,sDAAd,CAAN;AAA8E;;AAE5G,SAASe,qBAAT,CAA+BnB,GAA/B,EAAoCc,CAApC,EAAuC;AAAE,MAAIO,IAAI,GAAG,EAAX;AAAe,MAAIC,EAAE,GAAG,IAAT;AAAe,MAAIC,EAAE,GAAG,KAAT;AAAgB,MAAIC,EAAE,GAAGC,SAAT;;AAAoB,MAAI;AAAE,SAAK,IAAIC,EAAE,GAAG1B,GAAG,CAACM,MAAM,CAACC,QAAR,CAAH,EAAT,EAAiCoB,EAAtC,EAA0C,EAAEL,EAAE,GAAG,CAACK,EAAE,GAAGD,EAAE,CAACE,IAAH,EAAN,EAAiBC,IAAxB,CAA1C,EAAyEP,EAAE,GAAG,IAA9E,EAAoF;AAAED,MAAAA,IAAI,CAACS,IAAL,CAAUH,EAAE,CAACxC,KAAb;;AAAqB,UAAI2B,CAAC,IAAIO,IAAI,CAACL,MAAL,KAAgBF,CAAzB,EAA4B;AAAQ;AAAE,GAAvJ,CAAwJ,OAAOiB,GAAP,EAAY;AAAER,IAAAA,EAAE,GAAG,IAAL;AAAWC,IAAAA,EAAE,GAAGO,GAAL;AAAW,GAA5L,SAAqM;AAAE,QAAI;AAAE,UAAI,CAACT,EAAD,IAAOI,EAAE,CAAC,QAAD,CAAF,IAAgB,IAA3B,EAAiCA,EAAE,CAAC,QAAD,CAAF;AAAiB,KAAxD,SAAiE;AAAE,UAAIH,EAAJ,EAAQ,MAAMC,EAAN;AAAW;AAAE;;AAAC,SAAOH,IAAP;AAAc;;AAEzZ,SAASH,eAAT,CAAyBlB,GAAzB,EAA8B;AAAE,MAAIW,KAAK,CAACE,OAAN,CAAcb,GAAd,CAAJ,EAAwB,OAAOA,GAAP;AAAa;AAErE;;;;;;;;;AAOA,SAASgC,gBAAT,CAA0BC,IAA1B,EAAgC;AAC9B,MAAIC,KAAK,GAAGjB,cAAc,CAACgB,IAAD,EAAO,CAAP,CAA1B;AAAA,MACIE,GAAG,GAAGD,KAAK,CAAC,CAAD,CADf;AAAA,MAEIE,GAAG,GAAGF,KAAK,CAAC,CAAD,CAFf;;AAIA,MAAIG,QAAQ,GAAGF,GAAf;AAAA,MACIG,QAAQ,GAAGF,GADf,CAL8B,CAMV;;AAEpB,MAAID,GAAG,GAAGC,GAAV,EAAe;AACbC,IAAAA,QAAQ,GAAGD,GAAX;AACAE,IAAAA,QAAQ,GAAGH,GAAX;AACD;;AAED,SAAO,CAACE,QAAD,EAAWC,QAAX,CAAP;AACD;AACD;;;;;;;;;;;AAWA,SAASC,aAAT,CAAuBC,SAAvB,EAAkCC,aAAlC,EAAiDC,gBAAjD,EAAmE;AACjE,MAAIF,SAAS,CAACG,GAAV,CAAc,CAAd,CAAJ,EAAsB;AACpB,WAAO,IAAIpD,QAAQ,CAACO,OAAb,CAAqB,CAArB,CAAP;AACD;;AAED,MAAI8C,UAAU,GAAGjD,WAAW,CAACG,OAAZ,CAAoB+C,aAApB,CAAkCL,SAAS,CAACM,QAAV,EAAlC,CAAjB,CALiE,CAKS;AAC1E;;;AAGA,MAAIC,eAAe,GAAG,IAAIxD,QAAQ,CAACO,OAAb,CAAqB,EAArB,EAAyBkD,GAAzB,CAA6BJ,UAA7B,CAAtB;AACA,MAAIK,SAAS,GAAGT,SAAS,CAACU,GAAV,CAAcH,eAAd,CAAhB,CAViE,CAUjB;;AAEhD,MAAII,cAAc,GAAGP,UAAU,KAAK,CAAf,GAAmB,IAAnB,GAA0B,GAA/C;AACA,MAAIQ,cAAc,GAAG,IAAI7D,QAAQ,CAACO,OAAb,CAAqBuD,IAAI,CAACC,IAAL,CAAUL,SAAS,CAACC,GAAV,CAAcC,cAAd,EAA8BL,QAA9B,EAAV,CAArB,EAA0ES,GAA1E,CAA8Eb,gBAA9E,EAAgGc,GAAhG,CAAoGL,cAApG,CAArB;AACA,MAAIM,UAAU,GAAGL,cAAc,CAACI,GAAf,CAAmBT,eAAnB,CAAjB;AACA,SAAON,aAAa,GAAGgB,UAAH,GAAgB,IAAIlE,QAAQ,CAACO,OAAb,CAAqBuD,IAAI,CAACC,IAAL,CAAUG,UAAV,CAArB,CAApC;AACD;AACD;;;;;;;;;;AAUA,SAASC,oBAAT,CAA8BvE,KAA9B,EAAqCwE,SAArC,EAAgDlB,aAAhD,EAA+D;AAC7D,MAAImB,IAAI,GAAG,CAAX,CAD6D,CAC/C;;AAEd,MAAIC,MAAM,GAAG,IAAItE,QAAQ,CAACO,OAAb,CAAqBX,KAArB,CAAb;;AAEA,MAAI,CAAC0E,MAAM,CAACC,KAAP,EAAD,IAAmBrB,aAAvB,EAAsC;AACpC,QAAIsB,MAAM,GAAGV,IAAI,CAACW,GAAL,CAAS7E,KAAT,CAAb;;AAEA,QAAI4E,MAAM,GAAG,CAAb,EAAgB;AACd;AACAH,MAAAA,IAAI,GAAG,IAAIrE,QAAQ,CAACO,OAAb,CAAqB,EAArB,EAAyBkD,GAAzB,CAA6BrD,WAAW,CAACG,OAAZ,CAAoB+C,aAApB,CAAkC1D,KAAlC,IAA2C,CAAxE,CAAP;AACA0E,MAAAA,MAAM,GAAG,IAAItE,QAAQ,CAACO,OAAb,CAAqBuD,IAAI,CAACY,KAAL,CAAWJ,MAAM,CAACX,GAAP,CAAWU,IAAX,EAAiBd,QAAjB,EAAX,CAArB,EAA8DU,GAA9D,CAAkEI,IAAlE,CAAT;AACD,KAJD,MAIO,IAAIG,MAAM,GAAG,CAAb,EAAgB;AACrB;AACAF,MAAAA,MAAM,GAAG,IAAItE,QAAQ,CAACO,OAAb,CAAqBuD,IAAI,CAACY,KAAL,CAAW9E,KAAX,CAArB,CAAT;AACD;AACF,GAXD,MAWO,IAAIA,KAAK,KAAK,CAAd,EAAiB;AACtB0E,IAAAA,MAAM,GAAG,IAAItE,QAAQ,CAACO,OAAb,CAAqBuD,IAAI,CAACY,KAAL,CAAW,CAACN,SAAS,GAAG,CAAb,IAAkB,CAA7B,CAArB,CAAT;AACD,GAFM,MAEA,IAAI,CAAClB,aAAL,EAAoB;AACzBoB,IAAAA,MAAM,GAAG,IAAItE,QAAQ,CAACO,OAAb,CAAqBuD,IAAI,CAACY,KAAL,CAAW9E,KAAX,CAArB,CAAT;AACD;;AAED,MAAI+E,WAAW,GAAGb,IAAI,CAACY,KAAL,CAAW,CAACN,SAAS,GAAG,CAAb,IAAkB,CAA7B,CAAlB;AACA,MAAIQ,EAAE,GAAG,CAAC,GAAGzE,MAAM,CAAC0E,OAAX,EAAoB,CAAC,GAAG1E,MAAM,CAAC2E,GAAX,EAAgB,UAAUC,CAAV,EAAa;AACxD,WAAOT,MAAM,CAACN,GAAP,CAAW,IAAIhE,QAAQ,CAACO,OAAb,CAAqBwE,CAAC,GAAGJ,WAAzB,EAAsCV,GAAtC,CAA0CI,IAA1C,CAAX,EAA4Dd,QAA5D,EAAP;AACD,GAF4B,CAApB,EAELpD,MAAM,CAAC6E,KAFF,CAAT;AAGA,SAAOJ,EAAE,CAAC,CAAD,EAAIR,SAAJ,CAAT;AACD;AACD;;;;;;;;;;;;AAYA,SAASa,aAAT,CAAuBrC,GAAvB,EAA4BC,GAA5B,EAAiCuB,SAAjC,EAA4ClB,aAA5C,EAA2D;AACzD,MAAIC,gBAAgB,GAAG+B,SAAS,CAACzD,MAAV,GAAmB,CAAnB,IAAwByD,SAAS,CAAC,CAAD,CAAT,KAAiBhD,SAAzC,GAAqDgD,SAAS,CAAC,CAAD,CAA9D,GAAoE,CAA3F,CADyD,CAGzD;;AACA,MAAI,CAACC,MAAM,CAACC,QAAP,CAAgB,CAACvC,GAAG,GAAGD,GAAP,KAAewB,SAAS,GAAG,CAA3B,CAAhB,CAAL,EAAqD;AACnD,WAAO;AACLC,MAAAA,IAAI,EAAE,IAAIrE,QAAQ,CAACO,OAAb,CAAqB,CAArB,CADD;AAEL8E,MAAAA,OAAO,EAAE,IAAIrF,QAAQ,CAACO,OAAb,CAAqB,CAArB,CAFJ;AAGL+E,MAAAA,OAAO,EAAE,IAAItF,QAAQ,CAACO,OAAb,CAAqB,CAArB;AAHJ,KAAP;AAKD,GAVwD,CAUvD;;;AAGF,MAAI8D,IAAI,GAAGrB,aAAa,CAAC,IAAIhD,QAAQ,CAACO,OAAb,CAAqBsC,GAArB,EAA0B0C,GAA1B,CAA8B3C,GAA9B,EAAmCe,GAAnC,CAAuCS,SAAS,GAAG,CAAnD,CAAD,EAAwDlB,aAAxD,EAAuEC,gBAAvE,CAAxB,CAbyD,CAayD;;AAElH,MAAImB,MAAJ,CAfyD,CAe7C;;AAEZ,MAAI1B,GAAG,IAAI,CAAP,IAAYC,GAAG,IAAI,CAAvB,EAA0B;AACxByB,IAAAA,MAAM,GAAG,IAAItE,QAAQ,CAACO,OAAb,CAAqB,CAArB,CAAT;AACD,GAFD,MAEO;AACL;AACA+D,IAAAA,MAAM,GAAG,IAAItE,QAAQ,CAACO,OAAb,CAAqBqC,GAArB,EAA0BoB,GAA1B,CAA8BnB,GAA9B,EAAmCc,GAAnC,CAAuC,CAAvC,CAAT,CAFK,CAE+C;;AAEpDW,IAAAA,MAAM,GAAGA,MAAM,CAACiB,GAAP,CAAW,IAAIvF,QAAQ,CAACO,OAAb,CAAqB+D,MAArB,EAA6BkB,GAA7B,CAAiCnB,IAAjC,CAAX,CAAT;AACD;;AAED,MAAIoB,UAAU,GAAG3B,IAAI,CAACC,IAAL,CAAUO,MAAM,CAACiB,GAAP,CAAW3C,GAAX,EAAgBe,GAAhB,CAAoBU,IAApB,EAA0Bd,QAA1B,EAAV,CAAjB;AACA,MAAImC,OAAO,GAAG5B,IAAI,CAACC,IAAL,CAAU,IAAI/D,QAAQ,CAACO,OAAb,CAAqBsC,GAArB,EAA0B0C,GAA1B,CAA8BjB,MAA9B,EAAsCX,GAAtC,CAA0CU,IAA1C,EAAgDd,QAAhD,EAAV,CAAd;AACA,MAAIoC,UAAU,GAAGF,UAAU,GAAGC,OAAb,GAAuB,CAAxC;;AAEA,MAAIC,UAAU,GAAGvB,SAAjB,EAA4B;AAC1B;AACA,WAAOa,aAAa,CAACrC,GAAD,EAAMC,GAAN,EAAWuB,SAAX,EAAsBlB,aAAtB,EAAqCC,gBAAgB,GAAG,CAAxD,CAApB;AACD;;AAED,MAAIwC,UAAU,GAAGvB,SAAjB,EAA4B;AAC1B;AACAsB,IAAAA,OAAO,GAAG7C,GAAG,GAAG,CAAN,GAAU6C,OAAO,IAAItB,SAAS,GAAGuB,UAAhB,CAAjB,GAA+CD,OAAzD;AACAD,IAAAA,UAAU,GAAG5C,GAAG,GAAG,CAAN,GAAU4C,UAAV,GAAuBA,UAAU,IAAIrB,SAAS,GAAGuB,UAAhB,CAA9C;AACD;;AAED,SAAO;AACLtB,IAAAA,IAAI,EAAEA,IADD;AAELgB,IAAAA,OAAO,EAAEf,MAAM,CAACiB,GAAP,CAAW,IAAIvF,QAAQ,CAACO,OAAb,CAAqBkF,UAArB,EAAiCxB,GAAjC,CAAqCI,IAArC,CAAX,CAFJ;AAGLiB,IAAAA,OAAO,EAAEhB,MAAM,CAACN,GAAP,CAAW,IAAIhE,QAAQ,CAACO,OAAb,CAAqBmF,OAArB,EAA8BzB,GAA9B,CAAkCI,IAAlC,CAAX;AAHJ,GAAP;AAKD;AACD;;;;;;;;;;AAUA,SAASuB,mBAAT,CAA6BC,KAA7B,EAAoC;AAClC,MAAIC,KAAK,GAAGpE,cAAc,CAACmE,KAAD,EAAQ,CAAR,CAA1B;AAAA,MACIjD,GAAG,GAAGkD,KAAK,CAAC,CAAD,CADf;AAAA,MAEIjD,GAAG,GAAGiD,KAAK,CAAC,CAAD,CAFf;;AAIA,MAAI1B,SAAS,GAAGc,SAAS,CAACzD,MAAV,GAAmB,CAAnB,IAAwByD,SAAS,CAAC,CAAD,CAAT,KAAiBhD,SAAzC,GAAqDgD,SAAS,CAAC,CAAD,CAA9D,GAAoE,CAApF;AACA,MAAIhC,aAAa,GAAGgC,SAAS,CAACzD,MAAV,GAAmB,CAAnB,IAAwByD,SAAS,CAAC,CAAD,CAAT,KAAiBhD,SAAzC,GAAqDgD,SAAS,CAAC,CAAD,CAA9D,GAAoE,IAAxF,CANkC,CAOlC;;AACA,MAAIa,KAAK,GAAGjC,IAAI,CAACjB,GAAL,CAASuB,SAAT,EAAoB,CAApB,CAAZ;;AAEA,MAAI4B,iBAAiB,GAAGvD,gBAAgB,CAAC,CAACG,GAAD,EAAMC,GAAN,CAAD,CAAxC;AAAA,MACIoD,kBAAkB,GAAGvE,cAAc,CAACsE,iBAAD,EAAoB,CAApB,CADvC;AAAA,MAEIE,MAAM,GAAGD,kBAAkB,CAAC,CAAD,CAF/B;AAAA,MAGIE,MAAM,GAAGF,kBAAkB,CAAC,CAAD,CAH/B;;AAKA,MAAIC,MAAM,KAAK,CAACE,QAAZ,IAAwBD,MAAM,KAAKC,QAAvC,EAAiD;AAC/C,QAAIC,OAAO,GAAGF,MAAM,KAAKC,QAAX,GAAsB,CAACF,MAAD,EAASI,MAAT,CAAgB9F,kBAAkB,CAAC,CAAC,GAAGL,MAAM,CAAC6E,KAAX,EAAkB,CAAlB,EAAqBZ,SAAS,GAAG,CAAjC,EAAoCU,GAApC,CAAwC,YAAY;AACzH,aAAOsB,QAAP;AACD,KAFsE,CAAD,CAAlC,CAAtB,GAEP5F,kBAAkB,CAAC,CAAC,GAAGL,MAAM,CAAC6E,KAAX,EAAkB,CAAlB,EAAqBZ,SAAS,GAAG,CAAjC,EAAoCU,GAApC,CAAwC,YAAY;AAC5E,aAAO,CAACsB,QAAR;AACD,KAFyB,CAAD,CAAlB,CAEHE,MAFG,CAEI,CAACH,MAAD,CAFJ,CAFP;;AAMA,WAAOvD,GAAG,GAAGC,GAAN,GAAY,CAAC,GAAG1C,MAAM,CAACoG,OAAX,EAAoBF,OAApB,CAAZ,GAA2CA,OAAlD;AACD;;AAED,MAAIH,MAAM,KAAKC,MAAf,EAAuB;AACrB,WAAOhC,oBAAoB,CAAC+B,MAAD,EAAS9B,SAAT,EAAoBlB,aAApB,CAA3B;AACD,GA3BiC,CA2BhC;;;AAGF,MAAIsD,cAAc,GAAGvB,aAAa,CAACiB,MAAD,EAASC,MAAT,EAAiBJ,KAAjB,EAAwB7C,aAAxB,CAAlC;AAAA,MACImB,IAAI,GAAGmC,cAAc,CAACnC,IAD1B;AAAA,MAEIgB,OAAO,GAAGmB,cAAc,CAACnB,OAF7B;AAAA,MAGIC,OAAO,GAAGkB,cAAc,CAAClB,OAH7B;;AAKA,MAAImB,MAAM,GAAGrG,WAAW,CAACG,OAAZ,CAAoBmG,SAApB,CAA8BrB,OAA9B,EAAuCC,OAAO,CAACtB,GAAR,CAAY,IAAIhE,QAAQ,CAACO,OAAb,CAAqB,GAArB,EAA0B0D,GAA1B,CAA8BI,IAA9B,CAAZ,CAAvC,EAAyFA,IAAzF,CAAb;;AAEA,SAAOzB,GAAG,GAAGC,GAAN,GAAY,CAAC,GAAG1C,MAAM,CAACoG,OAAX,EAAoBE,MAApB,CAAZ,GAA0CA,MAAjD;AACD;AACD;;;;;;;;;;AAUA,SAASE,eAAT,CAAyBC,KAAzB,EAAgC;AAC9B,MAAIC,KAAK,GAAGnF,cAAc,CAACkF,KAAD,EAAQ,CAAR,CAA1B;AAAA,MACIhE,GAAG,GAAGiE,KAAK,CAAC,CAAD,CADf;AAAA,MAEIhE,GAAG,GAAGgE,KAAK,CAAC,CAAD,CAFf;;AAIA,MAAIzC,SAAS,GAAGc,SAAS,CAACzD,MAAV,GAAmB,CAAnB,IAAwByD,SAAS,CAAC,CAAD,CAAT,KAAiBhD,SAAzC,GAAqDgD,SAAS,CAAC,CAAD,CAA9D,GAAoE,CAApF;AACA,MAAIhC,aAAa,GAAGgC,SAAS,CAACzD,MAAV,GAAmB,CAAnB,IAAwByD,SAAS,CAAC,CAAD,CAAT,KAAiBhD,SAAzC,GAAqDgD,SAAS,CAAC,CAAD,CAA9D,GAAoE,IAAxF,CAN8B,CAO9B;;AACA,MAAIa,KAAK,GAAGjC,IAAI,CAACjB,GAAL,CAASuB,SAAT,EAAoB,CAApB,CAAZ;;AAEA,MAAI0C,kBAAkB,GAAGrE,gBAAgB,CAAC,CAACG,GAAD,EAAMC,GAAN,CAAD,CAAzC;AAAA,MACIkE,kBAAkB,GAAGrF,cAAc,CAACoF,kBAAD,EAAqB,CAArB,CADvC;AAAA,MAEIZ,MAAM,GAAGa,kBAAkB,CAAC,CAAD,CAF/B;AAAA,MAGIZ,MAAM,GAAGY,kBAAkB,CAAC,CAAD,CAH/B;;AAKA,MAAIb,MAAM,KAAK,CAACE,QAAZ,IAAwBD,MAAM,KAAKC,QAAvC,EAAiD;AAC/C,WAAO,CAACxD,GAAD,EAAMC,GAAN,CAAP;AACD;;AAED,MAAIqD,MAAM,KAAKC,MAAf,EAAuB;AACrB,WAAOhC,oBAAoB,CAAC+B,MAAD,EAAS9B,SAAT,EAAoBlB,aAApB,CAA3B;AACD;;AAED,MAAImB,IAAI,GAAGrB,aAAa,CAAC,IAAIhD,QAAQ,CAACO,OAAb,CAAqB4F,MAArB,EAA6BZ,GAA7B,CAAiCW,MAAjC,EAAyCvC,GAAzC,CAA6CoC,KAAK,GAAG,CAArD,CAAD,EAA0D7C,aAA1D,EAAyE,CAAzE,CAAxB;AACA,MAAI0B,EAAE,GAAG,CAAC,GAAGzE,MAAM,CAAC0E,OAAX,EAAoB,CAAC,GAAG1E,MAAM,CAAC2E,GAAX,EAAgB,UAAUC,CAAV,EAAa;AACxD,WAAO,IAAI/E,QAAQ,CAACO,OAAb,CAAqB2F,MAArB,EAA6BlC,GAA7B,CAAiC,IAAIhE,QAAQ,CAACO,OAAb,CAAqBwE,CAArB,EAAwBd,GAAxB,CAA4BI,IAA5B,CAAjC,EAAoEd,QAApE,EAAP;AACD,GAF4B,CAApB,EAELpD,MAAM,CAAC6E,KAFF,CAAT;AAGA,MAAIyB,MAAM,GAAG7B,EAAE,CAAC,CAAD,EAAImB,KAAJ,CAAF,CAAaiB,MAAb,CAAoB,UAAUC,KAAV,EAAiB;AAChD,WAAOA,KAAK,IAAIf,MAAT,IAAmBe,KAAK,IAAId,MAAnC;AACD,GAFY,CAAb;AAGA,SAAOvD,GAAG,GAAGC,GAAN,GAAY,CAAC,GAAG1C,MAAM,CAACoG,OAAX,EAAoBE,MAApB,CAAZ,GAA0CA,MAAjD;AACD;AACD;;;;;;;;;;;AAWA,SAASS,0BAAT,CAAoCC,KAApC,EAA2C/C,SAA3C,EAAsD;AACpD,MAAIgD,KAAK,GAAG1F,cAAc,CAACyF,KAAD,EAAQ,CAAR,CAA1B;AAAA,MACIvE,GAAG,GAAGwE,KAAK,CAAC,CAAD,CADf;AAAA,MAEIvE,GAAG,GAAGuE,KAAK,CAAC,CAAD,CAFf;;AAIA,MAAIlE,aAAa,GAAGgC,SAAS,CAACzD,MAAV,GAAmB,CAAnB,IAAwByD,SAAS,CAAC,CAAD,CAAT,KAAiBhD,SAAzC,GAAqDgD,SAAS,CAAC,CAAD,CAA9D,GAAoE,IAAxF,CALoD,CAOpD;;AACA,MAAImC,kBAAkB,GAAG5E,gBAAgB,CAAC,CAACG,GAAD,EAAMC,GAAN,CAAD,CAAzC;AAAA,MACIyE,kBAAkB,GAAG5F,cAAc,CAAC2F,kBAAD,EAAqB,CAArB,CADvC;AAAA,MAEInB,MAAM,GAAGoB,kBAAkB,CAAC,CAAD,CAF/B;AAAA,MAGInB,MAAM,GAAGmB,kBAAkB,CAAC,CAAD,CAH/B;;AAKA,MAAIpB,MAAM,KAAK,CAACE,QAAZ,IAAwBD,MAAM,KAAKC,QAAvC,EAAiD;AAC/C,WAAO,CAACxD,GAAD,EAAMC,GAAN,CAAP;AACD;;AAED,MAAIqD,MAAM,KAAKC,MAAf,EAAuB;AACrB,WAAO,CAACD,MAAD,CAAP;AACD;;AAED,MAAIH,KAAK,GAAGjC,IAAI,CAACjB,GAAL,CAASuB,SAAT,EAAoB,CAApB,CAAZ;AACA,MAAIC,IAAI,GAAGrB,aAAa,CAAC,IAAIhD,QAAQ,CAACO,OAAb,CAAqB4F,MAArB,EAA6BZ,GAA7B,CAAiCW,MAAjC,EAAyCvC,GAAzC,CAA6CoC,KAAK,GAAG,CAArD,CAAD,EAA0D7C,aAA1D,EAAyE,CAAzE,CAAxB;;AAEA,MAAIuD,MAAM,GAAGjG,kBAAkB,CAACJ,WAAW,CAACG,OAAZ,CAAoBmG,SAApB,CAA8B,IAAI1G,QAAQ,CAACO,OAAb,CAAqB2F,MAArB,CAA9B,EAA4D,IAAIlG,QAAQ,CAACO,OAAb,CAAqB4F,MAArB,EAA6BZ,GAA7B,CAAiC,IAAIvF,QAAQ,CAACO,OAAb,CAAqB,IAArB,EAA2B0D,GAA3B,CAA+BI,IAA/B,CAAjC,CAA5D,EAAoIA,IAApI,CAAD,CAAlB,CAA8JiC,MAA9J,CAAqK,CAACH,MAAD,CAArK,CAAb;;AAEA,SAAOvD,GAAG,GAAGC,GAAN,GAAY,CAAC,GAAG1C,MAAM,CAACoG,OAAX,EAAoBE,MAApB,CAAZ,GAA0CA,MAAjD;AACD;;AAED,IAAI1G,iBAAiB,GAAG,CAAC,GAAGI,MAAM,CAACoH,OAAX,EAAoB3B,mBAApB,CAAxB;AACAjG,OAAO,CAACI,iBAAR,GAA4BA,iBAA5B;AACA,IAAID,aAAa,GAAG,CAAC,GAAGK,MAAM,CAACoH,OAAX,EAAoBZ,eAApB,CAApB;AACAhH,OAAO,CAACG,aAAR,GAAwBA,aAAxB;AACA,IAAID,wBAAwB,GAAG,CAAC,GAAGM,MAAM,CAACoH,OAAX,EAAoBL,0BAApB,CAA/B;AACAvH,OAAO,CAACE,wBAAR,GAAmCA,wBAAnC","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTickValuesFixedDomain = exports.getTickValues = exports.getNiceTickValues = void 0;\n\nvar _decimal = _interopRequireDefault(require(\"decimal.js-light\"));\n\nvar _utils = require(\"./util/utils\");\n\nvar _arithmetic = _interopRequireDefault(require(\"./util/arithmetic\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/**\n * Calculate a interval of a minimum value and a maximum value\n *\n * @param  {Number} min       The minimum value\n * @param  {Number} max       The maximum value\n * @return {Array} An interval\n */\nfunction getValidInterval(_ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n      min = _ref2[0],\n      max = _ref2[1];\n\n  var validMin = min,\n      validMax = max; // exchange\n\n  if (min > max) {\n    validMin = max;\n    validMax = min;\n  }\n\n  return [validMin, validMax];\n}\n/**\n * Calculate the step which is easy to understand between ticks, like 10, 20, 25\n *\n * @param  {Decimal} roughStep        The rough step calculated by deviding the\n * difference by the tickCount\n * @param  {Boolean} allowDecimals    Allow the ticks to be decimals or not\n * @param  {Integer} correctionFactor A correction factor\n * @return {Decimal} The step which is easy to understand between two ticks\n */\n\n\nfunction getFormatStep(roughStep, allowDecimals, correctionFactor) {\n  if (roughStep.lte(0)) {\n    return new _decimal.default(0);\n  }\n\n  var digitCount = _arithmetic.default.getDigitCount(roughStep.toNumber()); // The ratio between the rough step and the smallest number which has a bigger\n  // order of magnitudes than the rough step\n\n\n  var digitCountValue = new _decimal.default(10).pow(digitCount);\n  var stepRatio = roughStep.div(digitCountValue); // When an integer and a float multiplied, the accuracy of result may be wrong\n\n  var stepRatioScale = digitCount !== 1 ? 0.05 : 0.1;\n  var amendStepRatio = new _decimal.default(Math.ceil(stepRatio.div(stepRatioScale).toNumber())).add(correctionFactor).mul(stepRatioScale);\n  var formatStep = amendStepRatio.mul(digitCountValue);\n  return allowDecimals ? formatStep : new _decimal.default(Math.ceil(formatStep));\n}\n/**\n * calculate the ticks when the minimum value equals to the maximum value\n *\n * @param  {Number}  value         The minimum valuue which is also the maximum value\n * @param  {Integer} tickCount     The count of ticks\n * @param  {Boolean} allowDecimals Allow the ticks to be decimals or not\n * @return {Array}                 ticks\n */\n\n\nfunction getTickOfSingleValue(value, tickCount, allowDecimals) {\n  var step = 1; // calculate the middle value of ticks\n\n  var middle = new _decimal.default(value);\n\n  if (!middle.isint() && allowDecimals) {\n    var absVal = Math.abs(value);\n\n    if (absVal < 1) {\n      // The step should be a float number when the difference is smaller than 1\n      step = new _decimal.default(10).pow(_arithmetic.default.getDigitCount(value) - 1);\n      middle = new _decimal.default(Math.floor(middle.div(step).toNumber())).mul(step);\n    } else if (absVal > 1) {\n      // Return the maximum integer which is smaller than 'value' when 'value' is greater than 1\n      middle = new _decimal.default(Math.floor(value));\n    }\n  } else if (value === 0) {\n    middle = new _decimal.default(Math.floor((tickCount - 1) / 2));\n  } else if (!allowDecimals) {\n    middle = new _decimal.default(Math.floor(value));\n  }\n\n  var middleIndex = Math.floor((tickCount - 1) / 2);\n  var fn = (0, _utils.compose)((0, _utils.map)(function (n) {\n    return middle.add(new _decimal.default(n - middleIndex).mul(step)).toNumber();\n  }), _utils.range);\n  return fn(0, tickCount);\n}\n/**\n * Calculate the step\n *\n * @param  {Number}  min              The minimum value of an interval\n * @param  {Number}  max              The maximum value of an interval\n * @param  {Integer} tickCount        The count of ticks\n * @param  {Boolean} allowDecimals    Allow the ticks to be decimals or not\n * @param  {Number}  correctionFactor A correction factor\n * @return {Object}  The step, minimum value of ticks, maximum value of ticks\n */\n\n\nfunction calculateStep(min, max, tickCount, allowDecimals) {\n  var correctionFactor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n\n  // dirty hack (for recharts' test)\n  if (!Number.isFinite((max - min) / (tickCount - 1))) {\n    return {\n      step: new _decimal.default(0),\n      tickMin: new _decimal.default(0),\n      tickMax: new _decimal.default(0)\n    };\n  } // The step which is easy to understand between two ticks\n\n\n  var step = getFormatStep(new _decimal.default(max).sub(min).div(tickCount - 1), allowDecimals, correctionFactor); // A medial value of ticks\n\n  var middle; // When 0 is inside the interval, 0 should be a tick\n\n  if (min <= 0 && max >= 0) {\n    middle = new _decimal.default(0);\n  } else {\n    // calculate the middle value\n    middle = new _decimal.default(min).add(max).div(2); // minus modulo value\n\n    middle = middle.sub(new _decimal.default(middle).mod(step));\n  }\n\n  var belowCount = Math.ceil(middle.sub(min).div(step).toNumber());\n  var upCount = Math.ceil(new _decimal.default(max).sub(middle).div(step).toNumber());\n  var scaleCount = belowCount + upCount + 1;\n\n  if (scaleCount > tickCount) {\n    // When more ticks need to cover the interval, step should be bigger.\n    return calculateStep(min, max, tickCount, allowDecimals, correctionFactor + 1);\n  }\n\n  if (scaleCount < tickCount) {\n    // When less ticks can cover the interval, we should add some additional ticks\n    upCount = max > 0 ? upCount + (tickCount - scaleCount) : upCount;\n    belowCount = max > 0 ? belowCount : belowCount + (tickCount - scaleCount);\n  }\n\n  return {\n    step: step,\n    tickMin: middle.sub(new _decimal.default(belowCount).mul(step)),\n    tickMax: middle.add(new _decimal.default(upCount).mul(step))\n  };\n}\n/**\n * Calculate the ticks of an interval, the count of ticks will be guraranteed\n *\n * @param  {Number}  min, max      min: The minimum value, max: The maximum value\n * @param  {Integer} tickCount     The count of ticks\n * @param  {Boolean} allowDecimals Allow the ticks to be decimals or not\n * @return {Array}   ticks\n */\n\n\nfunction getNiceTickValuesFn(_ref3) {\n  var _ref4 = _slicedToArray(_ref3, 2),\n      min = _ref4[0],\n      max = _ref4[1];\n\n  var tickCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  // More than two ticks should be return\n  var count = Math.max(tickCount, 2);\n\n  var _getValidInterval = getValidInterval([min, max]),\n      _getValidInterval2 = _slicedToArray(_getValidInterval, 2),\n      cormin = _getValidInterval2[0],\n      cormax = _getValidInterval2[1];\n\n  if (cormin === -Infinity || cormax === Infinity) {\n    var _values = cormax === Infinity ? [cormin].concat(_toConsumableArray((0, _utils.range)(0, tickCount - 1).map(function () {\n      return Infinity;\n    }))) : _toConsumableArray((0, _utils.range)(0, tickCount - 1).map(function () {\n      return -Infinity;\n    })).concat([cormax]);\n\n    return min > max ? (0, _utils.reverse)(_values) : _values;\n  }\n\n  if (cormin === cormax) {\n    return getTickOfSingleValue(cormin, tickCount, allowDecimals);\n  } // Get the step between two ticks\n\n\n  var _calculateStep = calculateStep(cormin, cormax, count, allowDecimals),\n      step = _calculateStep.step,\n      tickMin = _calculateStep.tickMin,\n      tickMax = _calculateStep.tickMax;\n\n  var values = _arithmetic.default.rangeStep(tickMin, tickMax.add(new _decimal.default(0.1).mul(step)), step);\n\n  return min > max ? (0, _utils.reverse)(values) : values;\n}\n/**\n * Calculate the ticks of an interval, the count of ticks won't be guraranteed\n *\n * @param  {Number}  min, max      min: The minimum value, max: The maximum value\n * @param  {Integer} tickCount     The count of ticks\n * @param  {Boolean} allowDecimals Allow the ticks to be decimals or not\n * @return {Array}   ticks\n */\n\n\nfunction getTickValuesFn(_ref5) {\n  var _ref6 = _slicedToArray(_ref5, 2),\n      min = _ref6[0],\n      max = _ref6[1];\n\n  var tickCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  // More than two ticks should be return\n  var count = Math.max(tickCount, 2);\n\n  var _getValidInterval3 = getValidInterval([min, max]),\n      _getValidInterval4 = _slicedToArray(_getValidInterval3, 2),\n      cormin = _getValidInterval4[0],\n      cormax = _getValidInterval4[1];\n\n  if (cormin === -Infinity || cormax === Infinity) {\n    return [min, max];\n  }\n\n  if (cormin === cormax) {\n    return getTickOfSingleValue(cormin, tickCount, allowDecimals);\n  }\n\n  var step = getFormatStep(new _decimal.default(cormax).sub(cormin).div(count - 1), allowDecimals, 0);\n  var fn = (0, _utils.compose)((0, _utils.map)(function (n) {\n    return new _decimal.default(cormin).add(new _decimal.default(n).mul(step)).toNumber();\n  }), _utils.range);\n  var values = fn(0, count).filter(function (entry) {\n    return entry >= cormin && entry <= cormax;\n  });\n  return min > max ? (0, _utils.reverse)(values) : values;\n}\n/**\n * Calculate the ticks of an interval, the count of ticks won't be guraranteed,\n * but the domain will be guaranteed\n *\n * @param  {Number}  min, max      min: The minimum value, max: The maximum value\n * @param  {Integer} tickCount     The count of ticks\n * @param  {Boolean} allowDecimals Allow the ticks to be decimals or not\n * @return {Array}   ticks\n */\n\n\nfunction getTickValuesFixedDomainFn(_ref7, tickCount) {\n  var _ref8 = _slicedToArray(_ref7, 2),\n      min = _ref8[0],\n      max = _ref8[1];\n\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n  // More than two ticks should be return\n  var _getValidInterval5 = getValidInterval([min, max]),\n      _getValidInterval6 = _slicedToArray(_getValidInterval5, 2),\n      cormin = _getValidInterval6[0],\n      cormax = _getValidInterval6[1];\n\n  if (cormin === -Infinity || cormax === Infinity) {\n    return [min, max];\n  }\n\n  if (cormin === cormax) {\n    return [cormin];\n  }\n\n  var count = Math.max(tickCount, 2);\n  var step = getFormatStep(new _decimal.default(cormax).sub(cormin).div(count - 1), allowDecimals, 0);\n\n  var values = _toConsumableArray(_arithmetic.default.rangeStep(new _decimal.default(cormin), new _decimal.default(cormax).sub(new _decimal.default(0.99).mul(step)), step)).concat([cormax]);\n\n  return min > max ? (0, _utils.reverse)(values) : values;\n}\n\nvar getNiceTickValues = (0, _utils.memoize)(getNiceTickValuesFn);\nexports.getNiceTickValues = getNiceTickValues;\nvar getTickValues = (0, _utils.memoize)(getTickValuesFn);\nexports.getTickValues = getTickValues;\nvar getTickValuesFixedDomain = (0, _utils.memoize)(getTickValuesFixedDomainFn);\nexports.getTickValuesFixedDomain = getTickValuesFixedDomain;"]},"metadata":{},"sourceType":"script"}